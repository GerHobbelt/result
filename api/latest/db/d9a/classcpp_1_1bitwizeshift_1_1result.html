<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Result: cpp::bitwizeshift::result&lt; T, E &gt; Class Template Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Result
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('db/d9a/classcpp_1_1bitwizeshift_1_1result.html','../../');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="../../d1/d94/classcpp_1_1bitwizeshift_1_1result-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cpp::bitwizeshift::result&lt; T, E &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The class template <code>result</code> manages result results from APIs, while encoding possible failure conditions.  
 <a href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../de/d80/result_8hpp_source.html">result.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a31818816735f9d348e96cabad0559153"><td class="memItemLeft" align="right" valign="top"><a id="a31818816735f9d348e96cabad0559153"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a31818816735f9d348e96cabad0559153">value_type</a> = T</td></tr>
<tr class="memdesc:a31818816735f9d348e96cabad0559153"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value type of this result. <br /></td></tr>
<tr class="separator:a31818816735f9d348e96cabad0559153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf649f8e04fe1e24ffa827d2dbd1bbc1"><td class="memItemLeft" align="right" valign="top"><a id="acf649f8e04fe1e24ffa827d2dbd1bbc1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#acf649f8e04fe1e24ffa827d2dbd1bbc1">error_type</a> = E</td></tr>
<tr class="memdesc:acf649f8e04fe1e24ffa827d2dbd1bbc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The error type of this result. <br /></td></tr>
<tr class="separator:acf649f8e04fe1e24ffa827d2dbd1bbc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16ff7aef394eda8b170c43df2a7e12e4"><td class="memItemLeft" align="right" valign="top"><a id="a16ff7aef394eda8b170c43df2a7e12e4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a16ff7aef394eda8b170c43df2a7e12e4">failure_type</a> = <a class="el" href="../../dc/dd0/classcpp_1_1bitwizeshift_1_1failure.html">failure</a>&lt; E &gt;</td></tr>
<tr class="memdesc:a16ff7aef394eda8b170c43df2a7e12e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The failure type. <br /></td></tr>
<tr class="separator:a16ff7aef394eda8b170c43df2a7e12e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d94be75171a6eaaaa16ebbea8213c42"><td class="memTemplParams" colspan="2"><a id="a5d94be75171a6eaaaa16ebbea8213c42"></a>
template&lt;typename U &gt; </td></tr>
<tr class="memitem:a5d94be75171a6eaaaa16ebbea8213c42"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a5d94be75171a6eaaaa16ebbea8213c42">rebind</a> = <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a>&lt; U, E &gt;</td></tr>
<tr class="memdesc:a5d94be75171a6eaaaa16ebbea8213c42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rebinds the result type. <br /></td></tr>
<tr class="separator:a5d94be75171a6eaaaa16ebbea8213c42"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a294cc61375e0b4d0a0865f5477cff931"><td class="memTemplParams" colspan="2">template&lt;typename U  = T, typename  = typename std::enable_if&lt;std::is_constructible&lt;U&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a294cc61375e0b4d0a0865f5477cff931"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a294cc61375e0b4d0a0865f5477cff931">result</a> () noexcept(std::is_nothrow_constructible&lt; U &gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a09c4adf83dccbd85f85023eaadd93131">value</a>)</td></tr>
<tr class="memdesc:a294cc61375e0b4d0a0865f5477cff931"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default-constructs an result with the underlying value type active.  <a href="#a294cc61375e0b4d0a0865f5477cff931">More...</a><br /></td></tr>
<tr class="separator:a294cc61375e0b4d0a0865f5477cff931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6808ac32ce9de8acc667a3f9185ed14a"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a6808ac32ce9de8acc667a3f9185ed14a">result</a> (const <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a> &amp;other)=default</td></tr>
<tr class="memdesc:a6808ac32ce9de8acc667a3f9185ed14a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructs this result.  <a href="#a6808ac32ce9de8acc667a3f9185ed14a">More...</a><br /></td></tr>
<tr class="separator:a6808ac32ce9de8acc667a3f9185ed14a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a839b1bf77f5a92ff56c119d558bc98c7"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a839b1bf77f5a92ff56c119d558bc98c7">result</a> (<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a> &amp;&amp;other)=default</td></tr>
<tr class="memdesc:a839b1bf77f5a92ff56c119d558bc98c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructs an result.  <a href="#a839b1bf77f5a92ff56c119d558bc98c7">More...</a><br /></td></tr>
<tr class="separator:a839b1bf77f5a92ff56c119d558bc98c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e9c452ba7ab0130f0f4776aec66f49a"><td class="memTemplParams" colspan="2">template&lt;typename... Args, typename  = typename std::enable_if&lt;std::is_constructible&lt;T,Args...&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a3e9c452ba7ab0130f0f4776aec66f49a"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a3e9c452ba7ab0130f0f4776aec66f49a">result</a> (<a class="el" href="../../d0/d99/structcpp_1_1bitwizeshift_1_1in__place__t.html">in_place_t</a>, Args &amp;&amp;... args) noexcept(std::is_nothrow_constructible&lt; T, Args... &gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a09c4adf83dccbd85f85023eaadd93131">value</a>)</td></tr>
<tr class="memdesc:a3e9c452ba7ab0130f0f4776aec66f49a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an result object that contains a value.  <a href="#a3e9c452ba7ab0130f0f4776aec66f49a">More...</a><br /></td></tr>
<tr class="separator:a3e9c452ba7ab0130f0f4776aec66f49a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae126a3af750a64eec9ebe7b2325afe2"><td class="memTemplParams" colspan="2">template&lt;typename U , typename... Args, typename  = typename std::enable_if&lt;std::is_constructible&lt;T, std::initializer_list&lt;U&gt;&amp;, Args...&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:aae126a3af750a64eec9ebe7b2325afe2"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#aae126a3af750a64eec9ebe7b2325afe2">result</a> (<a class="el" href="../../d0/d99/structcpp_1_1bitwizeshift_1_1in__place__t.html">in_place_t</a>, std::initializer_list&lt; U &gt; ilist, Args &amp;&amp;...args) noexcept(std::is_nothrow_constructible&lt; T, std::initializer_list&lt; U &gt;, Args... &gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a09c4adf83dccbd85f85023eaadd93131">value</a>)</td></tr>
<tr class="memdesc:aae126a3af750a64eec9ebe7b2325afe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an result object that contains a value.  <a href="#aae126a3af750a64eec9ebe7b2325afe2">More...</a><br /></td></tr>
<tr class="separator:aae126a3af750a64eec9ebe7b2325afe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a691fbdb19ae0c4fb858aa8425c51d5de"><td class="memTemplParams" colspan="2">template&lt;typename... Args, typename  = typename std::enable_if&lt;std::is_constructible&lt;E,Args...&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a691fbdb19ae0c4fb858aa8425c51d5de"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a691fbdb19ae0c4fb858aa8425c51d5de">result</a> (<a class="el" href="../../d1/d00/structcpp_1_1bitwizeshift_1_1in__place__error__t.html">in_place_error_t</a>, Args &amp;&amp;... args) noexcept(std::is_nothrow_constructible&lt; E, Args... &gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a09c4adf83dccbd85f85023eaadd93131">value</a>)</td></tr>
<tr class="memdesc:a691fbdb19ae0c4fb858aa8425c51d5de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an result object that contains an error.  <a href="#a691fbdb19ae0c4fb858aa8425c51d5de">More...</a><br /></td></tr>
<tr class="separator:a691fbdb19ae0c4fb858aa8425c51d5de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59c7df8b675c1f7177b22a74da477f62"><td class="memTemplParams" colspan="2">template&lt;typename U , typename... Args, typename  = typename std::enable_if&lt;std::is_constructible&lt;E, std::initializer_list&lt;U&gt;&amp;, Args...&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a59c7df8b675c1f7177b22a74da477f62"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a59c7df8b675c1f7177b22a74da477f62">result</a> (<a class="el" href="../../d1/d00/structcpp_1_1bitwizeshift_1_1in__place__error__t.html">in_place_error_t</a>, std::initializer_list&lt; U &gt; ilist, Args &amp;&amp;...args) noexcept(std::is_nothrow_constructible&lt; E, std::initializer_list&lt; U &gt;, Args... &gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a09c4adf83dccbd85f85023eaadd93131">value</a>)</td></tr>
<tr class="memdesc:a59c7df8b675c1f7177b22a74da477f62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an result object that contains an error.  <a href="#a59c7df8b675c1f7177b22a74da477f62">More...</a><br /></td></tr>
<tr class="separator:a59c7df8b675c1f7177b22a74da477f62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5307dea65a0fd87bdcd48c70a6827b10"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a5307dea65a0fd87bdcd48c70a6827b10">operator=</a> (const <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a> &amp;other) -&gt; <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a> &amp;=default</td></tr>
<tr class="memdesc:a5307dea65a0fd87bdcd48c70a6827b10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assigns the result stored in <code>other</code>.  <a href="#a5307dea65a0fd87bdcd48c70a6827b10">More...</a><br /></td></tr>
<tr class="separator:a5307dea65a0fd87bdcd48c70a6827b10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7001dcd67ce0f053e77e70100fdc82e0"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a7001dcd67ce0f053e77e70100fdc82e0">operator=</a> (<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a> &amp;&amp;other) -&gt; <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a> &amp;=default</td></tr>
<tr class="memdesc:a7001dcd67ce0f053e77e70100fdc82e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assigns the result stored in <code>other</code>.  <a href="#a7001dcd67ce0f053e77e70100fdc82e0">More...</a><br /></td></tr>
<tr class="separator:a7001dcd67ce0f053e77e70100fdc82e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa0909f15e9e8b97cfdf89bc4e880176"><td class="memTemplParams" colspan="2">template&lt;typename T2 , typename E2 , typename  = typename std::enable_if&lt;detail::result_is_copy_convert_assignable&lt;T,E,T2,E2&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:afa0909f15e9e8b97cfdf89bc4e880176"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#afa0909f15e9e8b97cfdf89bc4e880176">operator=</a> (const <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a>&lt; T2, E2 &gt; &amp;other) noexcept(std::is_nothrow_assignable&lt; T, const T2 &amp;&gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a09c4adf83dccbd85f85023eaadd93131">value</a> &amp;&amp;std::is_nothrow_assignable&lt; E, const E2 &amp;&gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a09c4adf83dccbd85f85023eaadd93131">value</a>) -&gt; <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a> &amp;</td></tr>
<tr class="memdesc:afa0909f15e9e8b97cfdf89bc4e880176"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy-converts the state of <code>other</code>.  <a href="#afa0909f15e9e8b97cfdf89bc4e880176">More...</a><br /></td></tr>
<tr class="separator:afa0909f15e9e8b97cfdf89bc4e880176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7964841611e21dcdaa0c6ad324b65be"><td class="memTemplParams" colspan="2">template&lt;typename T2 , typename E2 , typename  = typename std::enable_if&lt;detail::result_is_move_convert_assignable&lt;T,E,T2,E2&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:aa7964841611e21dcdaa0c6ad324b65be"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#aa7964841611e21dcdaa0c6ad324b65be">operator=</a> (<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a>&lt; T2, E2 &gt; &amp;&amp;other) noexcept(std::is_nothrow_assignable&lt; T, T2 &amp;&amp;&gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a09c4adf83dccbd85f85023eaadd93131">value</a> &amp;&amp;std::is_nothrow_assignable&lt; E, E2 &amp;&amp;&gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a09c4adf83dccbd85f85023eaadd93131">value</a>) -&gt; <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a> &amp;</td></tr>
<tr class="memdesc:aa7964841611e21dcdaa0c6ad324b65be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-converts the state of <code>other</code>.  <a href="#aa7964841611e21dcdaa0c6ad324b65be">More...</a><br /></td></tr>
<tr class="separator:aa7964841611e21dcdaa0c6ad324b65be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedce2ad25c705ae82c5bc1ebe1edc0d9"><td class="memTemplParams" colspan="2">template&lt;typename U , typename  = typename std::enable_if&lt;detail::result_is_value_assignable&lt;T,U&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:aedce2ad25c705ae82c5bc1ebe1edc0d9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#aedce2ad25c705ae82c5bc1ebe1edc0d9">operator=</a> (U &amp;&amp;<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a09c4adf83dccbd85f85023eaadd93131">value</a>) noexcept(std::is_nothrow_assignable&lt; T, U &gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a09c4adf83dccbd85f85023eaadd93131">value</a>) -&gt; <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a> &amp;</td></tr>
<tr class="memdesc:aedce2ad25c705ae82c5bc1ebe1edc0d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perfect-forwarded assignment.  <a href="#aedce2ad25c705ae82c5bc1ebe1edc0d9">More...</a><br /></td></tr>
<tr class="separator:aedce2ad25c705ae82c5bc1ebe1edc0d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acda405f686109c4b531f5103b2568742"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#acda405f686109c4b531f5103b2568742">operator bool</a> () const noexcept</td></tr>
<tr class="memdesc:acda405f686109c4b531f5103b2568742"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether <code>*this</code> contains a value.  <a href="#acda405f686109c4b531f5103b2568742">More...</a><br /></td></tr>
<tr class="separator:acda405f686109c4b531f5103b2568742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79f30ed79bcf8cf9ac9ecd50b8e9350a"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a79f30ed79bcf8cf9ac9ecd50b8e9350a">has_value</a> () const noexcept -&gt; bool</td></tr>
<tr class="memdesc:a79f30ed79bcf8cf9ac9ecd50b8e9350a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether <code>*this</code> contains a value.  <a href="#a79f30ed79bcf8cf9ac9ecd50b8e9350a">More...</a><br /></td></tr>
<tr class="separator:a79f30ed79bcf8cf9ac9ecd50b8e9350a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eef3852c1040fafef81e5dcc80cf09e"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a7eef3852c1040fafef81e5dcc80cf09e">has_error</a> () const noexcept -&gt; bool</td></tr>
<tr class="memdesc:a7eef3852c1040fafef81e5dcc80cf09e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether <code>*this</code> contains an error.  <a href="#a7eef3852c1040fafef81e5dcc80cf09e">More...</a><br /></td></tr>
<tr class="separator:a7eef3852c1040fafef81e5dcc80cf09e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add08dfcd937a7fccd5e83ccf699e9279"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:add08dfcd937a7fccd5e83ccf699e9279"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#add08dfcd937a7fccd5e83ccf699e9279">and_then</a> (U &amp;&amp;<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a09c4adf83dccbd85f85023eaadd93131">value</a>) const -&gt; <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a>&lt; typename std::decay&lt; U &gt;::type, E &gt;</td></tr>
<tr class="memdesc:add08dfcd937a7fccd5e83ccf699e9279"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an result containing <code>value</code> if this result contains a value, otherwise returns an result containing the current error.  <a href="#add08dfcd937a7fccd5e83ccf699e9279">More...</a><br /></td></tr>
<tr class="separator:add08dfcd937a7fccd5e83ccf699e9279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a376f846df51982f34e3ec3f952c39f80"><td class="memTemplParams" colspan="2">template&lt;typename T2 , typename E2 , typename std::enable_if&lt; detail::result_is_implicit_copy_convertible&lt; T, E, T2, E2 &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a376f846df51982f34e3ec3f952c39f80"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a376f846df51982f34e3ec3f952c39f80">result</a> (const <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a>&lt; T2, E2 &gt; &amp;other) noexcept(std::is_nothrow_constructible&lt; T, const T2 &amp;&gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a09c4adf83dccbd85f85023eaadd93131">value</a> &amp;&amp;std::is_nothrow_constructible&lt; E, const E2 &amp;&gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a09c4adf83dccbd85f85023eaadd93131">value</a>)</td></tr>
<tr class="memdesc:a376f846df51982f34e3ec3f952c39f80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converting copy constructor.  <a href="#a376f846df51982f34e3ec3f952c39f80">More...</a><br /></td></tr>
<tr class="separator:a376f846df51982f34e3ec3f952c39f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a376f846df51982f34e3ec3f952c39f80"><td class="memTemplParams" colspan="2">template&lt;typename T2 , typename E2 , typename std::enable_if&lt; detail::result_is_explicit_copy_convertible&lt; T, E, T2, E2 &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a376f846df51982f34e3ec3f952c39f80"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a376f846df51982f34e3ec3f952c39f80">result</a> (const <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a>&lt; T2, E2 &gt; &amp;other) noexcept(std::is_nothrow_constructible&lt; T, const T2 &amp;&gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a09c4adf83dccbd85f85023eaadd93131">value</a> &amp;&amp;std::is_nothrow_constructible&lt; E, const E2 &amp;&gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a09c4adf83dccbd85f85023eaadd93131">value</a>)</td></tr>
<tr class="memdesc:a376f846df51982f34e3ec3f952c39f80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converting copy constructor.  <a href="#a376f846df51982f34e3ec3f952c39f80">More...</a><br /></td></tr>
<tr class="separator:a376f846df51982f34e3ec3f952c39f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a1077f5f78da88859f109ff2b2756a0e1"><td class="memTemplParams" colspan="2">template&lt;typename T2 , typename E2 , typename std::enable_if&lt; detail::result_is_implicit_move_convertible&lt; T, E, T2, E2 &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a1077f5f78da88859f109ff2b2756a0e1"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a1077f5f78da88859f109ff2b2756a0e1">result</a> (<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a>&lt; T2, E2 &gt; &amp;&amp;other) noexcept(std::is_nothrow_constructible&lt; T, T2 &amp;&amp;&gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a09c4adf83dccbd85f85023eaadd93131">value</a> &amp;&amp;std::is_nothrow_constructible&lt; E, E2 &amp;&amp;&gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a09c4adf83dccbd85f85023eaadd93131">value</a>)</td></tr>
<tr class="memdesc:a1077f5f78da88859f109ff2b2756a0e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converting move constructor.  <a href="#a1077f5f78da88859f109ff2b2756a0e1">More...</a><br /></td></tr>
<tr class="separator:a1077f5f78da88859f109ff2b2756a0e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1077f5f78da88859f109ff2b2756a0e1"><td class="memTemplParams" colspan="2">template&lt;typename T2 , typename E2 , typename std::enable_if&lt; detail::result_is_explicit_move_convertible&lt; T, E, T2, E2 &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a1077f5f78da88859f109ff2b2756a0e1"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a1077f5f78da88859f109ff2b2756a0e1">result</a> (<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a>&lt; T2, E2 &gt; &amp;&amp;other) noexcept(std::is_nothrow_constructible&lt; T, T2 &amp;&amp;&gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a09c4adf83dccbd85f85023eaadd93131">value</a> &amp;&amp;std::is_nothrow_constructible&lt; E, E2 &amp;&amp;&gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a09c4adf83dccbd85f85023eaadd93131">value</a>)</td></tr>
<tr class="memdesc:a1077f5f78da88859f109ff2b2756a0e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converting move constructor.  <a href="#a1077f5f78da88859f109ff2b2756a0e1">More...</a><br /></td></tr>
<tr class="separator:a1077f5f78da88859f109ff2b2756a0e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aeb12608ba169d73dcac5204aefe5adb3"><td class="memTemplParams" colspan="2">template&lt;typename E2 , typename  = typename std::enable_if&lt;std::is_constructible&lt;E,const E2&amp;&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:aeb12608ba169d73dcac5204aefe5adb3"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#aeb12608ba169d73dcac5204aefe5adb3">result</a> (const <a class="el" href="../../dc/dd0/classcpp_1_1bitwizeshift_1_1failure.html">failure</a>&lt; E2 &gt; &amp;e) noexcept(std::is_nothrow_constructible&lt; E, const E2 &amp;&gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a09c4adf83dccbd85f85023eaadd93131">value</a>)</td></tr>
<tr class="memdesc:aeb12608ba169d73dcac5204aefe5adb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the underlying error of this result.  <a href="#aeb12608ba169d73dcac5204aefe5adb3">More...</a><br /></td></tr>
<tr class="separator:aeb12608ba169d73dcac5204aefe5adb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3361d2b8a668de4335fada30b1c3d9b3"><td class="memTemplParams" colspan="2">template&lt;typename E2 , typename  = typename std::enable_if&lt;std::is_constructible&lt;E,E2&amp;&amp;&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a3361d2b8a668de4335fada30b1c3d9b3"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a3361d2b8a668de4335fada30b1c3d9b3">result</a> (<a class="el" href="../../dc/dd0/classcpp_1_1bitwizeshift_1_1failure.html">failure</a>&lt; E2 &gt; &amp;&amp;e) noexcept(std::is_nothrow_constructible&lt; E, E2 &amp;&amp;&gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a09c4adf83dccbd85f85023eaadd93131">value</a>)</td></tr>
<tr class="memdesc:a3361d2b8a668de4335fada30b1c3d9b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the underlying error of this result.  <a href="#a3361d2b8a668de4335fada30b1c3d9b3">More...</a><br /></td></tr>
<tr class="separator:a3361d2b8a668de4335fada30b1c3d9b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a32a98dddc040fe525855b443115167e8"><td class="memTemplParams" colspan="2">template&lt;typename U , typename std::enable_if&lt; detail::result_is_explicit_value_convertible&lt; T, U &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a32a98dddc040fe525855b443115167e8"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a32a98dddc040fe525855b443115167e8">result</a> (U &amp;&amp;<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a09c4adf83dccbd85f85023eaadd93131">value</a>) noexcept(std::is_nothrow_constructible&lt; T, U &gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a09c4adf83dccbd85f85023eaadd93131">value</a>)</td></tr>
<tr class="memdesc:a32a98dddc040fe525855b443115167e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an result object that contains a value.  <a href="#a32a98dddc040fe525855b443115167e8">More...</a><br /></td></tr>
<tr class="separator:a32a98dddc040fe525855b443115167e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32a98dddc040fe525855b443115167e8"><td class="memTemplParams" colspan="2">template&lt;typename U , typename std::enable_if&lt; detail::result_is_implicit_value_convertible&lt; T, U &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a32a98dddc040fe525855b443115167e8"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a32a98dddc040fe525855b443115167e8">result</a> (U &amp;&amp;<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a09c4adf83dccbd85f85023eaadd93131">value</a>) noexcept(std::is_nothrow_constructible&lt; T, U &gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a09c4adf83dccbd85f85023eaadd93131">value</a>)</td></tr>
<tr class="memdesc:a32a98dddc040fe525855b443115167e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an result object that contains a value.  <a href="#a32a98dddc040fe525855b443115167e8">More...</a><br /></td></tr>
<tr class="separator:a32a98dddc040fe525855b443115167e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aae159b2584abc4f61f055c60888dbee0"><td class="memTemplParams" colspan="2">template&lt;typename E2 , typename  = typename std::enable_if&lt;detail::result_is_failure_assignable&lt;E,const E2&amp;&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:aae159b2584abc4f61f055c60888dbee0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#aae159b2584abc4f61f055c60888dbee0">operator=</a> (const <a class="el" href="../../dc/dd0/classcpp_1_1bitwizeshift_1_1failure.html">failure</a>&lt; E2 &gt; &amp;other) noexcept(std::is_nothrow_assignable&lt; E, const E2 &amp;&gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a09c4adf83dccbd85f85023eaadd93131">value</a>) -&gt; <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a> &amp;</td></tr>
<tr class="memdesc:aae159b2584abc4f61f055c60888dbee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perfect-forwarded assignment.  <a href="#aae159b2584abc4f61f055c60888dbee0">More...</a><br /></td></tr>
<tr class="separator:aae159b2584abc4f61f055c60888dbee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3b72a65bedcf9ddabfab257d4873764"><td class="memTemplParams" colspan="2">template&lt;typename E2 , typename  = typename std::enable_if&lt;detail::result_is_failure_assignable&lt;E,E2&amp;&amp;&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:ae3b72a65bedcf9ddabfab257d4873764"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#ae3b72a65bedcf9ddabfab257d4873764">operator=</a> (<a class="el" href="../../dc/dd0/classcpp_1_1bitwizeshift_1_1failure.html">failure</a>&lt; E2 &gt; &amp;&amp;other) noexcept(std::is_nothrow_assignable&lt; E, E2 &amp;&amp;&gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a09c4adf83dccbd85f85023eaadd93131">value</a>) -&gt; <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a> &amp;</td></tr>
<tr class="memdesc:ae3b72a65bedcf9ddabfab257d4873764"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perfect-forwarded assignment.  <a href="#ae3b72a65bedcf9ddabfab257d4873764">More...</a><br /></td></tr>
<tr class="separator:ae3b72a65bedcf9ddabfab257d4873764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a9908e855f6073bc448e001ebca51ba18"><td class="memItemLeft" align="right" valign="top">RESULT_CPP14_CONSTEXPR auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a9908e855f6073bc448e001ebca51ba18">operator-&gt;</a> () noexcept -&gt; typename std::remove_reference&lt; T &gt;::type *</td></tr>
<tr class="memdesc:a9908e855f6073bc448e001ebca51ba18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses the contained value.  <a href="#a9908e855f6073bc448e001ebca51ba18">More...</a><br /></td></tr>
<tr class="separator:a9908e855f6073bc448e001ebca51ba18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd4501a78af0f9a2b18f9c05534f26e7"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#abd4501a78af0f9a2b18f9c05534f26e7">operator-&gt;</a> () const noexcept -&gt; typename std::remove_reference&lt; typename std::add_const&lt; T &gt;::type &gt;::type *</td></tr>
<tr class="memdesc:abd4501a78af0f9a2b18f9c05534f26e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses the contained value.  <a href="#abd4501a78af0f9a2b18f9c05534f26e7">More...</a><br /></td></tr>
<tr class="separator:abd4501a78af0f9a2b18f9c05534f26e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ae4d3d6bffeac27094e5c5557a4f4b006"><td class="memItemLeft" align="right" valign="top">RESULT_CPP14_CONSTEXPR auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#ae4d3d6bffeac27094e5c5557a4f4b006">operator*</a> () &amp;noexcept -&gt; typename std::add_lvalue_reference&lt; T &gt;::type</td></tr>
<tr class="memdesc:ae4d3d6bffeac27094e5c5557a4f4b006"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses the contained value.  <a href="#ae4d3d6bffeac27094e5c5557a4f4b006">More...</a><br /></td></tr>
<tr class="separator:ae4d3d6bffeac27094e5c5557a4f4b006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e761b0857cfb91a39f8fda8303600d0"><td class="memItemLeft" align="right" valign="top">RESULT_CPP14_CONSTEXPR auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a5e761b0857cfb91a39f8fda8303600d0">operator*</a> () &amp;&amp;noexcept -&gt; typename std::add_rvalue_reference&lt; T &gt;::type</td></tr>
<tr class="memdesc:a5e761b0857cfb91a39f8fda8303600d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses the contained value.  <a href="#a5e761b0857cfb91a39f8fda8303600d0">More...</a><br /></td></tr>
<tr class="separator:a5e761b0857cfb91a39f8fda8303600d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae12d54806dbdc15b4d4c4d3b3332564e"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#ae12d54806dbdc15b4d4c4d3b3332564e">operator*</a> () const &amp;noexcept -&gt; typename std::add_lvalue_reference&lt; typename std::add_const&lt; T &gt;::type &gt;::type</td></tr>
<tr class="memdesc:ae12d54806dbdc15b4d4c4d3b3332564e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses the contained value.  <a href="#ae12d54806dbdc15b4d4c4d3b3332564e">More...</a><br /></td></tr>
<tr class="separator:ae12d54806dbdc15b4d4c4d3b3332564e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16ba7a9fc834db8cdb32e3122c98168e"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a16ba7a9fc834db8cdb32e3122c98168e">operator*</a> () const &amp;&amp;noexcept -&gt; typename std::add_rvalue_reference&lt; typename std::add_const&lt; T &gt;::type &gt;::type</td></tr>
<tr class="memdesc:a16ba7a9fc834db8cdb32e3122c98168e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses the contained value.  <a href="#a16ba7a9fc834db8cdb32e3122c98168e">More...</a><br /></td></tr>
<tr class="separator:a16ba7a9fc834db8cdb32e3122c98168e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a09c4adf83dccbd85f85023eaadd93131"><td class="memItemLeft" align="right" valign="top">RESULT_CPP14_CONSTEXPR auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a09c4adf83dccbd85f85023eaadd93131">value</a> () &amp;-&gt; typename std::add_lvalue_reference&lt; T &gt;::type</td></tr>
<tr class="memdesc:a09c4adf83dccbd85f85023eaadd93131"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the contained value.  <a href="#a09c4adf83dccbd85f85023eaadd93131">More...</a><br /></td></tr>
<tr class="separator:a09c4adf83dccbd85f85023eaadd93131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ae66c7f04926ab5e5f7ad8fa411acf7"><td class="memItemLeft" align="right" valign="top">RESULT_CPP14_CONSTEXPR auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a6ae66c7f04926ab5e5f7ad8fa411acf7">value</a> () &amp;&amp;-&gt; typename std::add_rvalue_reference&lt; T &gt;::type</td></tr>
<tr class="memdesc:a6ae66c7f04926ab5e5f7ad8fa411acf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the contained value.  <a href="#a6ae66c7f04926ab5e5f7ad8fa411acf7">More...</a><br /></td></tr>
<tr class="separator:a6ae66c7f04926ab5e5f7ad8fa411acf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeefbda36edec6cf428b8bcb6045ea300"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#aeefbda36edec6cf428b8bcb6045ea300">value</a> () const &amp;-&gt; typename std::add_lvalue_reference&lt; typename std::add_const&lt; T &gt;::type &gt;::type</td></tr>
<tr class="memdesc:aeefbda36edec6cf428b8bcb6045ea300"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the contained value.  <a href="#aeefbda36edec6cf428b8bcb6045ea300">More...</a><br /></td></tr>
<tr class="separator:aeefbda36edec6cf428b8bcb6045ea300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a970c87c3b07799bc73341abffc9e0943"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a970c87c3b07799bc73341abffc9e0943">value</a> () const &amp;&amp;-&gt; typename std::add_rvalue_reference&lt; typename std::add_const&lt; T &gt;::type &gt;::type</td></tr>
<tr class="memdesc:a970c87c3b07799bc73341abffc9e0943"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the contained value.  <a href="#a970c87c3b07799bc73341abffc9e0943">More...</a><br /></td></tr>
<tr class="separator:a970c87c3b07799bc73341abffc9e0943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aee2decdd8c91bb782c76936dac82d4ec"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#aee2decdd8c91bb782c76936dac82d4ec">error</a> () const &amp;noexcept(std::is_nothrow_constructible&lt; E &gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a09c4adf83dccbd85f85023eaadd93131">value</a> &amp;&amp;std::is_nothrow_copy_constructible&lt; E &gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a09c4adf83dccbd85f85023eaadd93131">value</a>) -&gt; E</td></tr>
<tr class="memdesc:aee2decdd8c91bb782c76936dac82d4ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the contained error, if one exists, or a default-constructed error value.  <a href="#aee2decdd8c91bb782c76936dac82d4ec">More...</a><br /></td></tr>
<tr class="separator:aee2decdd8c91bb782c76936dac82d4ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b6761e6fcb3491aaf184e9807aef4fc"><td class="memItemLeft" align="right" valign="top">RESULT_CPP14_CONSTEXPR auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a1b6761e6fcb3491aaf184e9807aef4fc">error</a> () &amp;&amp;noexcept(std::is_nothrow_constructible&lt; E &gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a09c4adf83dccbd85f85023eaadd93131">value</a> &amp;&amp;std::is_nothrow_move_constructible&lt; E &gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a09c4adf83dccbd85f85023eaadd93131">value</a>) -&gt; E</td></tr>
<tr class="memdesc:a1b6761e6fcb3491aaf184e9807aef4fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the contained error, if one exists, or a default-constructed error value.  <a href="#a1b6761e6fcb3491aaf184e9807aef4fc">More...</a><br /></td></tr>
<tr class="separator:a1b6761e6fcb3491aaf184e9807aef4fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54ed96521b164a8e28a531dea54e93c0"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a54ed96521b164a8e28a531dea54e93c0"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a54ed96521b164a8e28a531dea54e93c0">value_or</a> (U &amp;&amp;default_value) const &amp;-&gt; typename std::remove_reference&lt; T &gt;::type</td></tr>
<tr class="memdesc:a54ed96521b164a8e28a531dea54e93c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">}  <a href="#a54ed96521b164a8e28a531dea54e93c0">More...</a><br /></td></tr>
<tr class="separator:a54ed96521b164a8e28a531dea54e93c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78a9a3f8d66f7d17e3ab177b160838d4"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a78a9a3f8d66f7d17e3ab177b160838d4"><td class="memTemplItemLeft" align="right" valign="top">RESULT_CPP14_CONSTEXPR auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a78a9a3f8d66f7d17e3ab177b160838d4">value_or</a> (U &amp;&amp;default_value) &amp;&amp;-&gt; typename std::remove_reference&lt; T &gt;::type</td></tr>
<tr class="memdesc:a78a9a3f8d66f7d17e3ab177b160838d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the contained error, if one exists, or a default-constructed error value.  <a href="#a78a9a3f8d66f7d17e3ab177b160838d4">More...</a><br /></td></tr>
<tr class="separator:a78a9a3f8d66f7d17e3ab177b160838d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a3162ced153157cdd099b99fc72ea0147"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a3162ced153157cdd099b99fc72ea0147"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a3162ced153157cdd099b99fc72ea0147">error_or</a> (U &amp;&amp;default_error) const &amp;-&gt; <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#acf649f8e04fe1e24ffa827d2dbd1bbc1">error_type</a></td></tr>
<tr class="memdesc:a3162ced153157cdd099b99fc72ea0147"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the contained error if <code>*this</code> has an error, otherwise returns <code>default_error</code>.  <a href="#a3162ced153157cdd099b99fc72ea0147">More...</a><br /></td></tr>
<tr class="separator:a3162ced153157cdd099b99fc72ea0147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1776eaa3c7b5b4b2859f14b80a6ed232"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a1776eaa3c7b5b4b2859f14b80a6ed232"><td class="memTemplItemLeft" align="right" valign="top">RESULT_CPP14_CONSTEXPR auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a1776eaa3c7b5b4b2859f14b80a6ed232">error_or</a> (U &amp;&amp;default_error) &amp;&amp;-&gt; <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#acf649f8e04fe1e24ffa827d2dbd1bbc1">error_type</a></td></tr>
<tr class="memdesc:a1776eaa3c7b5b4b2859f14b80a6ed232"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the contained error if <code>*this</code> has an error, otherwise returns <code>default_error</code>.  <a href="#a1776eaa3c7b5b4b2859f14b80a6ed232">More...</a><br /></td></tr>
<tr class="separator:a1776eaa3c7b5b4b2859f14b80a6ed232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a09b04c3c34cc8838e5591fd20baab399"><td class="memTemplParams" colspan="2">template&lt;typename Fn &gt; </td></tr>
<tr class="memitem:a09b04c3c34cc8838e5591fd20baab399"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a09b04c3c34cc8838e5591fd20baab399">flat_map</a> (Fn &amp;&amp;fn) const &amp;-&gt; detail::invoke_result_t&lt; Fn, const T &amp;&gt;</td></tr>
<tr class="memdesc:a09b04c3c34cc8838e5591fd20baab399"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes the function <code>fn</code> with the value of this result as the argument.  <a href="#a09b04c3c34cc8838e5591fd20baab399">More...</a><br /></td></tr>
<tr class="separator:a09b04c3c34cc8838e5591fd20baab399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82d9a1fec1adc104280cbf7a422c2f2b"><td class="memTemplParams" colspan="2">template&lt;typename Fn &gt; </td></tr>
<tr class="memitem:a82d9a1fec1adc104280cbf7a422c2f2b"><td class="memTemplItemLeft" align="right" valign="top">RESULT_CPP14_CONSTEXPR auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a82d9a1fec1adc104280cbf7a422c2f2b">flat_map</a> (Fn &amp;&amp;fn) &amp;&amp;-&gt; detail::invoke_result_t&lt; Fn, T &amp;&amp;&gt;</td></tr>
<tr class="memdesc:a82d9a1fec1adc104280cbf7a422c2f2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes the function <code>fn</code> with the value of this result as the argument.  <a href="#a82d9a1fec1adc104280cbf7a422c2f2b">More...</a><br /></td></tr>
<tr class="separator:a82d9a1fec1adc104280cbf7a422c2f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ac5408bec36641d45519026297e040c00"><td class="memTemplParams" colspan="2">template&lt;typename Fn &gt; </td></tr>
<tr class="memitem:ac5408bec36641d45519026297e040c00"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#ac5408bec36641d45519026297e040c00">map</a> (Fn &amp;&amp;fn) const &amp;-&gt; <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a>&lt; detail::invoke_result_t&lt; Fn, const T &amp;&gt;, E &gt;</td></tr>
<tr class="memdesc:ac5408bec36641d45519026297e040c00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes the function <code>fn</code> with the value of this result as the argument.  <a href="#ac5408bec36641d45519026297e040c00">More...</a><br /></td></tr>
<tr class="separator:ac5408bec36641d45519026297e040c00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e8edc6b7102165f58cef616640bfe35"><td class="memTemplParams" colspan="2">template&lt;typename Fn &gt; </td></tr>
<tr class="memitem:a0e8edc6b7102165f58cef616640bfe35"><td class="memTemplItemLeft" align="right" valign="top">RESULT_CPP14_CONSTEXPR auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a0e8edc6b7102165f58cef616640bfe35">map</a> (Fn &amp;&amp;fn) &amp;&amp;-&gt; <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a>&lt; detail::invoke_result_t&lt; Fn, T &amp;&amp;&gt;, E &gt;</td></tr>
<tr class="memdesc:a0e8edc6b7102165f58cef616640bfe35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes the function <code>fn</code> with the value of this result as the argument.  <a href="#a0e8edc6b7102165f58cef616640bfe35">More...</a><br /></td></tr>
<tr class="separator:a0e8edc6b7102165f58cef616640bfe35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a6219348bf0006ded08121027605677c1"><td class="memTemplParams" colspan="2">template&lt;typename Fn &gt; </td></tr>
<tr class="memitem:a6219348bf0006ded08121027605677c1"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a6219348bf0006ded08121027605677c1">map_error</a> (Fn &amp;&amp;fn) const &amp;-&gt; <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a>&lt; T, detail::invoke_result_t&lt; Fn, const E &amp;&gt;&gt;</td></tr>
<tr class="memdesc:a6219348bf0006ded08121027605677c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes the function <code>fn</code> with the error of this result as the argument.  <a href="#a6219348bf0006ded08121027605677c1">More...</a><br /></td></tr>
<tr class="separator:a6219348bf0006ded08121027605677c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cb08b1d61f7f68dddd10b1ae6314471"><td class="memTemplParams" colspan="2">template&lt;typename Fn &gt; </td></tr>
<tr class="memitem:a0cb08b1d61f7f68dddd10b1ae6314471"><td class="memTemplItemLeft" align="right" valign="top">RESULT_CPP14_CONSTEXPR auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a0cb08b1d61f7f68dddd10b1ae6314471">map_error</a> (Fn &amp;&amp;fn) &amp;&amp;-&gt; <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a>&lt; T, detail::invoke_result_t&lt; Fn, E &amp;&amp;&gt;&gt;</td></tr>
<tr class="memdesc:a0cb08b1d61f7f68dddd10b1ae6314471"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes the function <code>fn</code> with the error of this result as the argument.  <a href="#a0cb08b1d61f7f68dddd10b1ae6314471">More...</a><br /></td></tr>
<tr class="separator:a0cb08b1d61f7f68dddd10b1ae6314471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a31eed75c8740edf56cd6ba3caae8f638"><td class="memTemplParams" colspan="2">template&lt;typename Fn &gt; </td></tr>
<tr class="memitem:a31eed75c8740edf56cd6ba3caae8f638"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a31eed75c8740edf56cd6ba3caae8f638">flat_map_error</a> (Fn &amp;&amp;fn) const &amp;-&gt; detail::invoke_result_t&lt; Fn, const E &amp;&gt;</td></tr>
<tr class="memdesc:a31eed75c8740edf56cd6ba3caae8f638"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes the function <code>fn</code> with the error of this result as the argument.  <a href="#a31eed75c8740edf56cd6ba3caae8f638">More...</a><br /></td></tr>
<tr class="separator:a31eed75c8740edf56cd6ba3caae8f638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b1d4678009a235c12b70ea24c0dea86"><td class="memTemplParams" colspan="2">template&lt;typename Fn &gt; </td></tr>
<tr class="memitem:a6b1d4678009a235c12b70ea24c0dea86"><td class="memTemplItemLeft" align="right" valign="top">RESULT_CPP14_CONSTEXPR auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a6b1d4678009a235c12b70ea24c0dea86">flat_map_error</a> (Fn &amp;&amp;fn) &amp;&amp;-&gt; detail::invoke_result_t&lt; Fn, E &amp;&amp;&gt;</td></tr>
<tr class="memdesc:a6b1d4678009a235c12b70ea24c0dea86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes the function <code>fn</code> with the error of this result as the argument.  <a href="#a6b1d4678009a235c12b70ea24c0dea86">More...</a><br /></td></tr>
<tr class="separator:a6b1d4678009a235c12b70ea24c0dea86"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a65d3ad0b808ae578a08ec9cde8a6adac"><td class="memTemplParams" colspan="2"><a id="a65d3ad0b808ae578a08ec9cde8a6adac"></a>
template&lt;typename T2 , typename E2 &gt; </td></tr>
<tr class="memitem:a65d3ad0b808ae578a08ec9cde8a6adac"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>result</b></td></tr>
<tr class="separator:a65d3ad0b808ae578a08ec9cde8a6adac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, typename E&gt;<br />
class cpp::bitwizeshift::result&lt; T, E &gt;</h3>

<p>The class template <code>result</code> manages result results from APIs, while encoding possible failure conditions. </p>
<p>A common use-case for result is the return value of a function that may fail. As opposed to other approaches, such as <code>std::pair&lt;T,bool&gt;</code> or <code>std::optional</code>, <code>result</code> more accurately conveys the intent of the user along with the failure condition to the caller. This effectively produces an orthogonal error handling mechanism that allows for exception safety while also allowing discrete testability of the return type.</p>
<p><code>result&lt;T,E&gt;</code> types may contain a <code>T</code> value, which signifies that an operation succeeded in producing the result value of type <code>T</code>. If an <code>result</code> does not contain a <code>T</code> value, it will always contain an <code>E</code> error condition instead.</p>
<p>An <code>result&lt;T,E&gt;</code> can always be queried for a possible error case by calling the <code><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#aee2decdd8c91bb782c76936dac82d4ec" title="Returns the contained error, if one exists, or a default-constructed error value. ...">error()</a></code> function, even if it contains a value. In the case that an <code>result&lt;T,E&gt;</code> contains a value object, this will simply return an <code>E</code> object constructed through default aggregate construction, as if through the expression <code>E{}</code>, which is assumed to be a "valid" (no-error) state for an <code>E</code> type. For example:</p>
<ul>
<li><code>std::error_code{}</code> produces a default-construct error-code, which is the "no error" state,</li>
<li>integral (or enum) error codes produce a <code>0</code> value (no error), thanks to zero-initialization,</li>
<li><code>std::exception_ptr{}</code> produces a null-pointer,</li>
<li><code>std::string{}</code> produces an empty string <code>""</code>,</li>
<li>etc.</li>
</ul>
<p>When an <code>result&lt;T,E&gt;</code> contains either a value or error, the storage for that object is guaranteed to be allocated as part of the result object's footprint, i.e. no dynamic memory allocation ever takes place. Thus, an result object models an object, not a pointer, even though the <code><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#ae4d3d6bffeac27094e5c5557a4f4b006" title="Accesses the contained value. ">operator*()</a></code> and <code>operator-&gt;()</code> are defined.</p>
<p>When an object of type <code>result&lt;T,E&gt;</code> is contextually converted to <code>bool</code>, the conversion returns <code>true</code> if the object contains a value and <code>false</code> if it contains an error.</p>
<p><code>result</code> objects do not have a "valueless" state like <code>variant</code>s do. Once an <code>result</code> has been constructed with a value or error, the active underlying type can only be changed through assignment which may is only enabled if construction is guaranteed to be <em>non-throwing</em>. This ensures that a valueless state cannot occur naturally.</p>
<p>Example Use: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> to_string(<span class="keywordtype">int</span> x) -&gt; result&lt;std::string&gt;</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span> {</div><div class="line">    <span class="keywordflow">return</span> std::stoi(x);</div><div class="line">  } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::invalid_argument&amp;) {</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="../../de/d80/result_8hpp.html#a38983cec7c1a46d8b77c9600768f29e7">fail</a>(std::errc::invalid_argument);</div><div class="line">  } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::std::out_of_range&amp;) {</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="../../de/d80/result_8hpp.html#a38983cec7c1a46d8b77c9600768f29e7">fail</a>(std::errc::result_out_of_range);</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>If using C++17 or above, <code>fail</code> can be replaced with <code>failure{...}</code> thanks to CTAD.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the underlying value type </td></tr>
    <tr><td class="paramname">E</td><td>the underlying error type </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../de/d80/result_8hpp_source.html#l00280">280</a> of file <a class="el" href="../../de/d80/result_8hpp_source.html">result.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a294cc61375e0b4d0a0865f5477cff931"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a294cc61375e0b4d0a0865f5477cff931">&#9670;&nbsp;</a></span>result() <span class="overload">[1/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<div class="memtemplate">
template&lt;typename U  = T, typename  = typename std::enable_if&lt;std::is_constructible&lt;U&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default-constructs an result with the underlying value type active. </p>
<p>This constructor is only enabled if <code>T</code> is default-constructible </p>

</div>
</div>
<a id="a6808ac32ce9de8acc667a3f9185ed14a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6808ac32ce9de8acc667a3f9185ed14a">&#9670;&nbsp;</a></span>result() <span class="overload">[2/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a>&lt; T, E &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructs this result. </p>
<p>If <code>other</code> contains a value, initializes the contained value as if direct-initializing (but not direct-list-initializing) an object of type <code>T</code> with the expression *other.</p>
<p>If other contains an error, constructs an object that contains a copy of that error.</p>
<dl class="section note"><dt>Note</dt><dd>This constructor is defined as deleted if <code>std::is_copy_constructible&lt;T&gt;::value</code> or <code>std::is_copy_constructible&lt;E&gt;::value</code> is <code>false</code></dd>
<dd>
This constructor is defined as trivial if both <code>std::is_trivially_copy_constructible&lt;T&gt;::value</code> and <code>std::is_trivially_copy_constructible&lt;E&gt;::value</code> are <code>true</code></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the result to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a839b1bf77f5a92ff56c119d558bc98c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a839b1bf77f5a92ff56c119d558bc98c7">&#9670;&nbsp;</a></span>result() <span class="overload">[3/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a>&lt; T, E &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructs an result. </p>
<p>If other contains a value, initializes the contained value as if direct-initializing (but not direct-list-initializing) an object of type T with the expression <code>std::move(*other)</code> and does not make other empty: a moved-from result still contains a value, but the value itself is moved from.</p>
<p>If other contains an error, move-constructs this result from that error.</p>
<dl class="section note"><dt>Note</dt><dd>This constructor is defined as deleted if <code>std::is_move_constructible&lt;T&gt;::value</code> or <code>std::is_move_constructible&lt;E&gt;::value</code> is <code>false</code></dd>
<dd>
This constructor is defined as trivial if both <code>std::is_trivially_move_constructible&lt;T&gt;::value</code> and <code>std::is_trivially_move_constructible&lt;E&gt;::value</code> are <code>true</code></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the result to move </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a376f846df51982f34e3ec3f952c39f80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a376f846df51982f34e3ec3f952c39f80">&#9670;&nbsp;</a></span>result() <span class="overload">[4/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<div class="memtemplate">
template&lt;typename T2 , typename E2 , typename std::enable_if&lt; detail::result_is_implicit_copy_convertible&lt; T, E, T2, E2 &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a>&lt; T2, E2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converting copy constructor. </p>
<p>If <code>other</code> contains a value, constructs an result object that contains a value, initialized as if direct-initializing (but not direct-list-initializing) an object of type <code>T</code> with the expression <code>*other</code>.</p>
<p>If <code>other</code> contains an error, constructs an result object that contains an error, initialized as if direct-initializing (but not direct-list-initializing) an object of type <code>E</code>.</p>
<dl class="section note"><dt>Note</dt><dd>This constructor does not participate in overload resolution unless the following conditions are met:<ul>
<li><code>std::is_constructible_v&lt;T, const U&amp;&gt;</code> is <code>true</code></li>
<li>T is not constructible or convertible from any expression of type (possibly const) <code>result&lt;T2,E2&gt;</code></li>
<li>E is not constructible or convertible from any expression of type (possible const) <code>result&lt;T2,E2&gt;</code></li>
</ul>
</dd>
<dd>
This constructor is explicit if and only if <code>std::is_convertible_v&lt;const T2&amp;, T&gt;</code> or <code>std::is_convertible_v&lt;const E2&amp;, E&gt;</code> is <code>false</code></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the other type to convert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a376f846df51982f34e3ec3f952c39f80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a376f846df51982f34e3ec3f952c39f80">&#9670;&nbsp;</a></span>result() <span class="overload">[5/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<div class="memtemplate">
template&lt;typename T2 , typename E2 , typename std::enable_if&lt; detail::result_is_explicit_copy_convertible&lt; T, E, T2, E2 &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a>&lt; T2, E2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converting copy constructor. </p>
<p>If <code>other</code> contains a value, constructs an result object that contains a value, initialized as if direct-initializing (but not direct-list-initializing) an object of type <code>T</code> with the expression <code>*other</code>.</p>
<p>If <code>other</code> contains an error, constructs an result object that contains an error, initialized as if direct-initializing (but not direct-list-initializing) an object of type <code>E</code>.</p>
<dl class="section note"><dt>Note</dt><dd>This constructor does not participate in overload resolution unless the following conditions are met:<ul>
<li><code>std::is_constructible_v&lt;T, const U&amp;&gt;</code> is <code>true</code></li>
<li>T is not constructible or convertible from any expression of type (possibly const) <code>result&lt;T2,E2&gt;</code></li>
<li>E is not constructible or convertible from any expression of type (possible const) <code>result&lt;T2,E2&gt;</code></li>
</ul>
</dd>
<dd>
This constructor is explicit if and only if <code>std::is_convertible_v&lt;const T2&amp;, T&gt;</code> or <code>std::is_convertible_v&lt;const E2&amp;, E&gt;</code> is <code>false</code></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the other type to convert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1077f5f78da88859f109ff2b2756a0e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1077f5f78da88859f109ff2b2756a0e1">&#9670;&nbsp;</a></span>result() <span class="overload">[6/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<div class="memtemplate">
template&lt;typename T2 , typename E2 , typename std::enable_if&lt; detail::result_is_implicit_move_convertible&lt; T, E, T2, E2 &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a>&lt; T2, E2 &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converting move constructor. </p>
<p>If <code>other</code> contains a value, constructs an result object that contains a value, initialized as if direct-initializing (but not direct-list-initializing) an object of type T with the expression <code>std::move(*other)</code>.</p>
<p>If <code>other</code> contains an error, constructs an result object that contains an error, initialized as if direct-initializing (but not direct-list-initializing) an object of type E&amp;&amp;.</p>
<dl class="section note"><dt>Note</dt><dd>This constructor does not participate in overload resolution unless the following conditions are met:<ul>
<li><code>std::is_constructible_v&lt;T, const U&amp;&gt;</code> is <code>true</code></li>
<li>T is not constructible or convertible from any expression of type (possibly const) <code>result&lt;T2,E2&gt;</code></li>
<li>E is not constructible or convertible from any expression of type (possible const) <code>result&lt;T2,E2&gt;</code></li>
</ul>
</dd>
<dd>
This constructor is explicit if and only if <code>std::is_convertible_v&lt;const T2&amp;, T&gt;</code> or <code>std::is_convertible_v&lt;const E2&amp;, E&gt;</code> is <code>false</code></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the other type to convert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1077f5f78da88859f109ff2b2756a0e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1077f5f78da88859f109ff2b2756a0e1">&#9670;&nbsp;</a></span>result() <span class="overload">[7/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<div class="memtemplate">
template&lt;typename T2 , typename E2 , typename std::enable_if&lt; detail::result_is_explicit_move_convertible&lt; T, E, T2, E2 &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a>&lt; T2, E2 &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converting move constructor. </p>
<p>If <code>other</code> contains a value, constructs an result object that contains a value, initialized as if direct-initializing (but not direct-list-initializing) an object of type T with the expression <code>std::move(*other)</code>.</p>
<p>If <code>other</code> contains an error, constructs an result object that contains an error, initialized as if direct-initializing (but not direct-list-initializing) an object of type E&amp;&amp;.</p>
<dl class="section note"><dt>Note</dt><dd>This constructor does not participate in overload resolution unless the following conditions are met:<ul>
<li><code>std::is_constructible_v&lt;T, const U&amp;&gt;</code> is <code>true</code></li>
<li>T is not constructible or convertible from any expression of type (possibly const) <code>result&lt;T2,E2&gt;</code></li>
<li>E is not constructible or convertible from any expression of type (possible const) <code>result&lt;T2,E2&gt;</code></li>
</ul>
</dd>
<dd>
This constructor is explicit if and only if <code>std::is_convertible_v&lt;const T2&amp;, T&gt;</code> or <code>std::is_convertible_v&lt;const E2&amp;, E&gt;</code> is <code>false</code></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the other type to convert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e9c452ba7ab0130f0f4776aec66f49a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e9c452ba7ab0130f0f4776aec66f49a">&#9670;&nbsp;</a></span>result() <span class="overload">[8/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<div class="memtemplate">
template&lt;typename... Args, typename  = typename std::enable_if&lt;std::is_constructible&lt;T,Args...&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d99/structcpp_1_1bitwizeshift_1_1in__place__t.html">in_place_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an result object that contains a value. </p>
<p>the value is initialized as if direct-initializing (but not direct-list-initializing) an object of type <code>T</code> from the arguments <code>std::forward&lt;Args&gt;(args)...</code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>the arguments to pass to T's constructor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae126a3af750a64eec9ebe7b2325afe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae126a3af750a64eec9ebe7b2325afe2">&#9670;&nbsp;</a></span>result() <span class="overload">[9/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<div class="memtemplate">
template&lt;typename U , typename... Args, typename  = typename std::enable_if&lt;std::is_constructible&lt;T, std::initializer_list&lt;U&gt;&amp;, Args...&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d99/structcpp_1_1bitwizeshift_1_1in__place__t.html">in_place_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; U &gt;&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an result object that contains a value. </p>
<p>The value is initialized as if direct-initializing (but not direct-list-initializing) an object of type <code>T</code> from the arguments <code>std::forward&lt;std::initializer_list&lt;U&gt;&gt;(ilist)</code>, <code>std::forward&lt;Args&gt;(args)...</code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ilist</td><td>An initializer list of entries to forward </td></tr>
    <tr><td class="paramname">args</td><td>the arguments to pass to T's constructor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a691fbdb19ae0c4fb858aa8425c51d5de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a691fbdb19ae0c4fb858aa8425c51d5de">&#9670;&nbsp;</a></span>result() <span class="overload">[10/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<div class="memtemplate">
template&lt;typename... Args, typename  = typename std::enable_if&lt;std::is_constructible&lt;E,Args...&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/d00/structcpp_1_1bitwizeshift_1_1in__place__error__t.html">in_place_error_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an result object that contains an error. </p>
<p>the value is initialized as if direct-initializing (but not direct-list-initializing) an object of type <code>E</code> from the arguments <code>std::forward&lt;Args&gt;(args)...</code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>the arguments to pass to E's constructor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a59c7df8b675c1f7177b22a74da477f62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59c7df8b675c1f7177b22a74da477f62">&#9670;&nbsp;</a></span>result() <span class="overload">[11/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<div class="memtemplate">
template&lt;typename U , typename... Args, typename  = typename std::enable_if&lt;std::is_constructible&lt;E, std::initializer_list&lt;U&gt;&amp;, Args...&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/d00/structcpp_1_1bitwizeshift_1_1in__place__error__t.html">in_place_error_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; U &gt;&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an result object that contains an error. </p>
<p>The value is initialized as if direct-initializing (but not direct-list-initializing) an object of type <code>E</code> from the arguments <code>std::forward&lt;std::initializer_list&lt;U&gt;&gt;(ilist)</code>, <code>std::forward&lt;Args&gt;(args)...</code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ilist</td><td>An initializer list of entries to forward </td></tr>
    <tr><td class="paramname">args</td><td>the arguments to pass to Es constructor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeb12608ba169d73dcac5204aefe5adb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb12608ba169d73dcac5204aefe5adb3">&#9670;&nbsp;</a></span>result() <span class="overload">[12/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<div class="memtemplate">
template&lt;typename E2 , typename  = typename std::enable_if&lt;std::is_constructible&lt;E,const E2&amp;&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/dd0/classcpp_1_1bitwizeshift_1_1failure.html">failure</a>&lt; E2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the underlying error of this result. </p>
<dl class="section note"><dt>Note</dt><dd>This constructor only participates in overload resolution if <code>E</code> is constructible from <code>e</code> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the failure error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3361d2b8a668de4335fada30b1c3d9b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3361d2b8a668de4335fada30b1c3d9b3">&#9670;&nbsp;</a></span>result() <span class="overload">[13/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<div class="memtemplate">
template&lt;typename E2 , typename  = typename std::enable_if&lt;std::is_constructible&lt;E,E2&amp;&amp;&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dd0/classcpp_1_1bitwizeshift_1_1failure.html">failure</a>&lt; E2 &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the underlying error of this result. </p>
<dl class="section note"><dt>Note</dt><dd>This constructor only participates in overload resolution if <code>E</code> is constructible from <code>e</code> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the failure error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a32a98dddc040fe525855b443115167e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32a98dddc040fe525855b443115167e8">&#9670;&nbsp;</a></span>result() <span class="overload">[14/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<div class="memtemplate">
template&lt;typename U , typename std::enable_if&lt; detail::result_is_explicit_value_convertible&lt; T, U &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a> </td>
          <td>(</td>
          <td class="paramtype">U &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an result object that contains a value. </p>
<p>The value is initialized as if direct-initializing (but not direct-list-initializing) an object of type T with the expression value.</p>
<dl class="section note"><dt>Note</dt><dd>This constructor is constexpr if the constructor of T selected by direct-initialization is constexpr</dd>
<dd>
This constructor does not participate in overload resolution unless <code>std::is_constructible_v&lt;T, U&amp;&amp;&gt;</code> is true and <code>decay_t&lt;U&gt;</code> is neither <code><a class="el" href="../../d0/d99/structcpp_1_1bitwizeshift_1_1in__place__t.html" title="A structure for representing in-place construction. ">in_place_t</a></code>, <code><a class="el" href="../../d1/d00/structcpp_1_1bitwizeshift_1_1in__place__error__t.html" title="A structure for representing in-place construction of an error type. ">in_place_error_t</a></code>, nor an <code>result</code> type.</dd>
<dd>
This constructor is explicit if and only if <code>std::is_convertible_v&lt;U&amp;&amp;, T&gt;</code> is <code>false</code></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a32a98dddc040fe525855b443115167e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32a98dddc040fe525855b443115167e8">&#9670;&nbsp;</a></span>result() <span class="overload">[15/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<div class="memtemplate">
template&lt;typename U , typename std::enable_if&lt; detail::result_is_implicit_value_convertible&lt; T, U &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a> </td>
          <td>(</td>
          <td class="paramtype">U &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an result object that contains a value. </p>
<p>The value is initialized as if direct-initializing (but not direct-list-initializing) an object of type T with the expression value.</p>
<dl class="section note"><dt>Note</dt><dd>This constructor is constexpr if the constructor of T selected by direct-initialization is constexpr</dd>
<dd>
This constructor does not participate in overload resolution unless <code>std::is_constructible_v&lt;T, U&amp;&amp;&gt;</code> is true and <code>decay_t&lt;U&gt;</code> is neither <code><a class="el" href="../../d0/d99/structcpp_1_1bitwizeshift_1_1in__place__t.html" title="A structure for representing in-place construction. ">in_place_t</a></code>, <code><a class="el" href="../../d1/d00/structcpp_1_1bitwizeshift_1_1in__place__error__t.html" title="A structure for representing in-place construction of an error type. ">in_place_error_t</a></code>, nor an <code>result</code> type.</dd>
<dd>
This constructor is explicit if and only if <code>std::is_convertible_v&lt;U&amp;&amp;, T&gt;</code> is <code>false</code></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="add08dfcd937a7fccd5e83ccf699e9279"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add08dfcd937a7fccd5e83ccf699e9279">&#9670;&nbsp;</a></span>and_then()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::and_then </td>
          <td>(</td>
          <td class="paramtype">U &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const -&gt;  <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a>&lt; typename std::decay&lt; U &gt;::type, E &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an result containing <code>value</code> if this result contains a value, otherwise returns an result containing the current error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value to return as an result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an result of <code>value</code> if this contains a value </dd></dl>

</div>
</div>
<a id="aee2decdd8c91bb782c76936dac82d4ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee2decdd8c91bb782c76936dac82d4ec">&#9670;&nbsp;</a></span>error() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::error </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;&amp; -&gt;  E</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the contained error, if one exists, or a default-constructed error value. </p>
<dl class="section return"><dt>Returns</dt><dd>the error or a default-constructed error value </dd></dl>

</div>
</div>
<a id="a1b6761e6fcb3491aaf184e9807aef4fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b6761e6fcb3491aaf184e9807aef4fc">&#9670;&nbsp;</a></span>error() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RESULT_CPP14_CONSTEXPR auto <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::error </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;&amp; -&gt;  E</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the contained error, if one exists, or a default-constructed error value. </p>
<dl class="section return"><dt>Returns</dt><dd>the error or a default-constructed error value </dd></dl>

</div>
</div>
<a id="a3162ced153157cdd099b99fc72ea0147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3162ced153157cdd099b99fc72ea0147">&#9670;&nbsp;</a></span>error_or() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::error_or </td>
          <td>(</td>
          <td class="paramtype">U &amp;&amp;&#160;</td>
          <td class="paramname"><em>default_error</em></td><td>)</td>
          <td> const &amp; -&gt;  <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#acf649f8e04fe1e24ffa827d2dbd1bbc1">error_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the contained error if <code>*this</code> has an error, otherwise returns <code>default_error</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">default_error</td><td>the error to use in case <code>*this</code> is empty </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the contained value or <code>default_error</code> </dd></dl>

</div>
</div>
<a id="a1776eaa3c7b5b4b2859f14b80a6ed232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1776eaa3c7b5b4b2859f14b80a6ed232">&#9670;&nbsp;</a></span>error_or() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RESULT_CPP14_CONSTEXPR auto <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::error_or </td>
          <td>(</td>
          <td class="paramtype">U &amp;&amp;&#160;</td>
          <td class="paramname"><em>default_error</em></td><td>)</td>
          <td> &amp;&amp; -&gt;  <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#acf649f8e04fe1e24ffa827d2dbd1bbc1">error_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the contained error if <code>*this</code> has an error, otherwise returns <code>default_error</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">default_error</td><td>the error to use in case <code>*this</code> is empty </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the contained value or <code>default_error</code> </dd></dl>

</div>
</div>
<a id="a09b04c3c34cc8838e5591fd20baab399"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09b04c3c34cc8838e5591fd20baab399">&#9670;&nbsp;</a></span>flat_map() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<div class="memtemplate">
template&lt;typename Fn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::flat_map </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>fn</em></td><td>)</td>
          <td> const &amp; -&gt;  detail::invoke_result_t&lt; Fn, const T &amp;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invokes the function <code>fn</code> with the value of this result as the argument. </p>
<p>If this result contains an error, an result of the error is returned</p>
<p>The function being called must return an <code>result</code> type or the program is ill-formed</p>
<p>If this is called on an rvalue of <code>result</code> which contains an error, the returned <code>result</code> is constructed from an rvalue of that error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn</td><td>the function to invoke with this </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the function being called </dd></dl>

</div>
</div>
<a id="a82d9a1fec1adc104280cbf7a422c2f2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82d9a1fec1adc104280cbf7a422c2f2b">&#9670;&nbsp;</a></span>flat_map() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<div class="memtemplate">
template&lt;typename Fn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RESULT_CPP14_CONSTEXPR auto <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::flat_map </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>fn</em></td><td>)</td>
          <td> &amp;&amp; -&gt;  detail::invoke_result_t&lt; Fn, T &amp;&amp;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invokes the function <code>fn</code> with the value of this result as the argument. </p>
<p>If this result contains an error, an result of the error is returned</p>
<p>The function being called must return an <code>result</code> type or the program is ill-formed</p>
<p>If this is called on an rvalue of <code>result</code> which contains an error, the returned <code>result</code> is constructed from an rvalue of that error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn</td><td>the function to invoke with this </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the function being called </dd></dl>

</div>
</div>
<a id="a31eed75c8740edf56cd6ba3caae8f638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31eed75c8740edf56cd6ba3caae8f638">&#9670;&nbsp;</a></span>flat_map_error() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<div class="memtemplate">
template&lt;typename Fn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::flat_map_error </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>fn</em></td><td>)</td>
          <td> const &amp; -&gt;  detail::invoke_result_t&lt; Fn, const E &amp;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invokes the function <code>fn</code> with the error of this result as the argument. </p>
<p>If this result contains a value, an result of the value is returned</p>
<p>The function being called must return an <code>result</code> type or the program is ill-formed</p>
<p>If this is called on an rvalue of <code>result</code> which contains an error, the returned <code>result</code> is constructed from an rvalue of that error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn</td><td>the function to invoke with this </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the function being called </dd></dl>

</div>
</div>
<a id="a6b1d4678009a235c12b70ea24c0dea86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b1d4678009a235c12b70ea24c0dea86">&#9670;&nbsp;</a></span>flat_map_error() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<div class="memtemplate">
template&lt;typename Fn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RESULT_CPP14_CONSTEXPR auto <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::flat_map_error </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>fn</em></td><td>)</td>
          <td> &amp;&amp; -&gt;  detail::invoke_result_t&lt; Fn, E &amp;&amp;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invokes the function <code>fn</code> with the error of this result as the argument. </p>
<p>If this result contains a value, an result of the value is returned</p>
<p>The function being called must return an <code>result</code> type or the program is ill-formed</p>
<p>If this is called on an rvalue of <code>result</code> which contains an error, the returned <code>result</code> is constructed from an rvalue of that error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn</td><td>the function to invoke with this </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the function being called </dd></dl>

</div>
</div>
<a id="a7eef3852c1040fafef81e5dcc80cf09e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eef3852c1040fafef81e5dcc80cf09e">&#9670;&nbsp;</a></span>has_error()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::has_error </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt;  bool</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether <code>*this</code> contains an error. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>*this</code> contains an error, <code>false</code> if <code>*this</code> contains a value </dd></dl>

</div>
</div>
<a id="a79f30ed79bcf8cf9ac9ecd50b8e9350a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79f30ed79bcf8cf9ac9ecd50b8e9350a">&#9670;&nbsp;</a></span>has_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::has_value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt;  bool</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether <code>*this</code> contains a value. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>*this</code> contains a value, <code>false</code> if <code>*this</code> contains an error </dd></dl>

</div>
</div>
<a id="ac5408bec36641d45519026297e040c00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5408bec36641d45519026297e040c00">&#9670;&nbsp;</a></span>map() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<div class="memtemplate">
template&lt;typename Fn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::map </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>fn</em></td><td>)</td>
          <td> const &amp; -&gt;  <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a>&lt; detail::invoke_result_t&lt; Fn, const T &amp;&gt;, E &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invokes the function <code>fn</code> with the value of this result as the argument. </p>
<p>If this result is an error, the result of this function is that error. Otherwise this function wraps the result and returns it as an result.</p>
<p>If this is called on an rvalue of <code>result</code> which contains an error, the returned <code>result</code> is constructed from an rvalue of that error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn</td><td>the function to invoke with this </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result result of the function invoked </dd></dl>

</div>
</div>
<a id="a0e8edc6b7102165f58cef616640bfe35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e8edc6b7102165f58cef616640bfe35">&#9670;&nbsp;</a></span>map() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<div class="memtemplate">
template&lt;typename Fn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RESULT_CPP14_CONSTEXPR auto <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::map </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>fn</em></td><td>)</td>
          <td> &amp;&amp; -&gt;  <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a>&lt; detail::invoke_result_t&lt; Fn, T &amp;&amp;&gt;, E &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invokes the function <code>fn</code> with the value of this result as the argument. </p>
<p>If this result is an error, the result of this function is that error. Otherwise this function wraps the result and returns it as an result.</p>
<p>If this is called on an rvalue of <code>result</code> which contains an error, the returned <code>result</code> is constructed from an rvalue of that error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn</td><td>the function to invoke with this </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result result of the function invoked </dd></dl>

</div>
</div>
<a id="a6219348bf0006ded08121027605677c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6219348bf0006ded08121027605677c1">&#9670;&nbsp;</a></span>map_error() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<div class="memtemplate">
template&lt;typename Fn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::map_error </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>fn</em></td><td>)</td>
          <td> const &amp; -&gt;  <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a>&lt; T, detail::invoke_result_t&lt; Fn, const E &amp;&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invokes the function <code>fn</code> with the error of this result as the argument. </p>
<p>If this result contains a value, the result of this function is that value. Otherwise the function is called with that error and returns the result as an result.</p>
<p>If this is called on an rvalue of <code>result</code> which contains a value, the returned <code>result</code> is constructed from an rvalue of that value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn</td><td>the function to invoke with this </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result result of the function invoked </dd></dl>

</div>
</div>
<a id="a0cb08b1d61f7f68dddd10b1ae6314471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cb08b1d61f7f68dddd10b1ae6314471">&#9670;&nbsp;</a></span>map_error() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<div class="memtemplate">
template&lt;typename Fn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RESULT_CPP14_CONSTEXPR auto <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::map_error </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>fn</em></td><td>)</td>
          <td> &amp;&amp; -&gt;  <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a>&lt; T, detail::invoke_result_t&lt; Fn, E &amp;&amp;&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invokes the function <code>fn</code> with the error of this result as the argument. </p>
<p>If this result contains a value, the result of this function is that value. Otherwise the function is called with that error and returns the result as an result.</p>
<p>If this is called on an rvalue of <code>result</code> which contains a value, the returned <code>result</code> is constructed from an rvalue of that value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn</td><td>the function to invoke with this </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result result of the function invoked </dd></dl>

</div>
</div>
<a id="acda405f686109c4b531f5103b2568742"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acda405f686109c4b531f5103b2568742">&#9670;&nbsp;</a></span>operator bool()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::operator bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether <code>*this</code> contains a value. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>*this</code> contains a value, <code>false</code> if <code>*this</code> does not contain a value </dd></dl>

</div>
</div>
<a id="ae4d3d6bffeac27094e5c5557a4f4b006"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4d3d6bffeac27094e5c5557a4f4b006">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RESULT_CPP14_CONSTEXPR auto <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp; -&gt;  typename std::add_lvalue_reference&lt; T &gt;::type</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accesses the contained value. </p>
<dl class="section note"><dt>Note</dt><dd>The behaviour is undefined if <code>*this</code> does not contain a value</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the contained value </dd></dl>

</div>
</div>
<a id="a5e761b0857cfb91a39f8fda8303600d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e761b0857cfb91a39f8fda8303600d0">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RESULT_CPP14_CONSTEXPR auto <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;&amp; -&gt;  typename std::add_rvalue_reference&lt; T &gt;::type</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accesses the contained value. </p>
<dl class="section note"><dt>Note</dt><dd>The behaviour is undefined if <code>*this</code> does not contain a value</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the contained value </dd></dl>

</div>
</div>
<a id="ae12d54806dbdc15b4d4c4d3b3332564e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae12d54806dbdc15b4d4c4d3b3332564e">&#9670;&nbsp;</a></span>operator*() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp; -&gt;  typename std::add_lvalue_reference&lt; typename std::add_const&lt; T &gt;::type &gt;::type</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accesses the contained value. </p>
<dl class="section note"><dt>Note</dt><dd>The behaviour is undefined if <code>*this</code> does not contain a value</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the contained value </dd></dl>

</div>
</div>
<a id="a16ba7a9fc834db8cdb32e3122c98168e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16ba7a9fc834db8cdb32e3122c98168e">&#9670;&nbsp;</a></span>operator*() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;&amp; -&gt;  typename std::add_rvalue_reference&lt; typename std::add_const&lt; T &gt;::type &gt;::type</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accesses the contained value. </p>
<dl class="section note"><dt>Note</dt><dd>The behaviour is undefined if <code>*this</code> does not contain a value</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the contained value </dd></dl>

</div>
</div>
<a id="a9908e855f6073bc448e001ebca51ba18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9908e855f6073bc448e001ebca51ba18">&#9670;&nbsp;</a></span>operator->() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RESULT_CPP14_CONSTEXPR auto <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  typename std::remove_reference&lt; T &gt;::type *</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accesses the contained value. </p>
<dl class="section note"><dt>Note</dt><dd>The behavior is undefined if <code>*this</code> does not contain a value.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the contained value </dd></dl>

</div>
</div>
<a id="abd4501a78af0f9a2b18f9c05534f26e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd4501a78af0f9a2b18f9c05534f26e7">&#9670;&nbsp;</a></span>operator->() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt;  typename std::remove_reference&lt; typename std::add_const&lt; T &gt;::type &gt;::type *</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accesses the contained value. </p>
<dl class="section note"><dt>Note</dt><dd>The behavior is undefined if <code>*this</code> does not contain a value.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the contained value </dd></dl>

</div>
</div>
<a id="a5307dea65a0fd87bdcd48c70a6827b10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5307dea65a0fd87bdcd48c70a6827b10">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a>&lt; T, E &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt;  <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a> &amp;=default</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assigns the result stored in <code>other</code>. </p>
<dl class="section note"><dt>Note</dt><dd>This assignment operator only participates in overload resolution if the following conditions are met:<ul>
<li><code>std::is_nothrow_copy_constructible_v&lt;T&gt;</code> is <code>true</code>, and</li>
<li><code>std::is_nothrow_copy_constructible_v&lt;E&gt;</code> is <code>true</code> this restriction guarantees that no '</li>
</ul>
</dd>
<dd>
This assignment operator is defined as trivial if the following conditions are all <code>true</code>:<ul>
<li><code>std::is_trivially_copy_constructible&lt;T&gt;::value</code></li>
<li><code>std::is_trivially_copy_constructible&lt;E&gt;::value</code></li>
<li><code>std::is_trivially_copy_assignable&lt;T&gt;::value</code></li>
<li><code>std::is_trivially_copy_assignable&lt;E&gt;::value</code></li>
<li><code>std::is_trivially_destructible&lt;T&gt;::value</code></li>
<li><code>std::is_trivially_destructible&lt;E&gt;::value</code></li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the other result to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7001dcd67ce0f053e77e70100fdc82e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7001dcd67ce0f053e77e70100fdc82e0">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a>&lt; T, E &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt;  <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a> &amp;=default</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assigns the result stored in <code>other</code>. </p>
<dl class="section note"><dt>Note</dt><dd>This assignment operator only participates in overload resolution if the following conditions are met:<ul>
<li><code>std::is_nothrow_copy_constructible_v&lt;T&gt;</code> is <code>true</code>, and</li>
<li><code>std::is_nothrow_copy_constructible_v&lt;E&gt;</code> is <code>true</code> this restriction guarantees that no 'valueless_by_exception` state may occur.</li>
</ul>
</dd>
<dd>
This assignment operator is defined as trivial if the following conditions are all <code>true</code>:<ul>
<li><code>std::is_trivially_move_constructible&lt;T&gt;::value</code></li>
<li><code>std::is_trivially_move_constructible&lt;E&gt;::value</code></li>
<li><code>std::is_trivially_move_assignable&lt;T&gt;::value</code></li>
<li><code>std::is_trivially_move_assignable&lt;E&gt;::value</code></li>
<li><code>std::is_trivially_destructible&lt;T&gt;::value</code></li>
<li><code>std::is_trivially_destructible&lt;E&gt;::value</code></li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the other result to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afa0909f15e9e8b97cfdf89bc4e880176"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa0909f15e9e8b97cfdf89bc4e880176">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<div class="memtemplate">
template&lt;typename T2 , typename E2 , typename  = typename std::enable_if&lt;detail::result_is_copy_convert_assignable&lt;T,E,T2,E2&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a>&lt; T2, E2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const &amp; -&gt;  <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy-converts the state of <code>other</code>. </p>
<p>If both <code>*this</code> and <code>other</code> contain either values or errors, the underlying value is constructed as if through assignment.</p>
<p>Otherwise if <code>*this</code> contains a value, but <code>other</code> contains an error, then the contained value is destroyed by calling its destructor. <code>*this</code> will no longer contain a value after the call, and will now contain <code>E</code> constructed as if direct-initializing (but not direct-list-initializing) an object with an argument of <code>const E2&amp;</code>.</p>
<p>If <code>other</code> contains a value and <code>*this</code> contains an error, then the contained error is destroyed by calling its destructor. <code>*this</code> now contains a value constructed as if direct-initializing (but not direct-list-initializing) an object with an argument of <code>const T2&amp;</code>.</p>
<dl class="section note"><dt>Note</dt><dd>The function does not participate in overload resolution unless<ul>
<li><code>std::is_nothrow_constructible_v&lt;T, const T2&amp;&gt;</code>, <code>std::is_assignable_v&lt;T&amp;, const T2&amp;&gt;</code>, <code>std::is_nothrow_constructible_v&lt;E, const E2&amp;&gt;</code>, <code>std::is_assignable_v&lt;E&amp;, const E2&amp;&gt;</code> are all true.</li>
<li>T is not constructible, convertible, or assignable from any expression of type (possibly const) <code>result&lt;T2,E2&gt;</code></li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the other result object to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to <code>(*this)</code> </dd></dl>

</div>
</div>
<a id="aa7964841611e21dcdaa0c6ad324b65be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7964841611e21dcdaa0c6ad324b65be">&#9670;&nbsp;</a></span>operator=() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<div class="memtemplate">
template&lt;typename T2 , typename E2 , typename  = typename std::enable_if&lt;detail::result_is_move_convert_assignable&lt;T,E,T2,E2&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a>&lt; T2, E2 &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> &amp;&amp; -&gt;  <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move-converts the state of <code>other</code>. </p>
<p>If both <code>*this</code> and <code>other</code> contain either values or errors, the underlying value is constructed as if through move-assignment.</p>
<p>Otherwise if <code>*this</code> contains a value, but <code>other</code> contains an error, then the contained value is destroyed by calling its destructor. <code>*this</code> will no longer contain a value after the call, and will now contain <code>E</code> constructed as if direct-initializing (but not direct-list-initializing) an object with an argument of <code>E2&amp;&amp;</code>.</p>
<p>If <code>other</code> contains a value and <code>*this</code> contains an error, then the contained error is destroyed by calling its destructor. <code>*this</code> now contains a value constructed as if direct-initializing (but not direct-list-initializing) an object with an argument of <code>T2&amp;&amp;</code>.</p>
<dl class="section note"><dt>Note</dt><dd>The function does not participate in overload resolution unless<ul>
<li><code>std::is_nothrow_constructible_v&lt;T, T2&amp;&amp;&gt;</code>, <code>std::is_assignable_v&lt;T&amp;, T2&amp;&amp;&gt;</code>, <code>std::is_nothrow_constructible_v&lt;E, E2&amp;&amp;&gt;</code>, <code>std::is_assignable_v&lt;E&amp;, E2&amp;&amp;&gt;</code> are all true.</li>
<li>T is not constructible, convertible, or assignable from any expression of type (possibly const) <code>result&lt;T2,E2&gt;</code></li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the other result object to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to <code>(*this)</code> </dd></dl>

</div>
</div>
<a id="aedce2ad25c705ae82c5bc1ebe1edc0d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedce2ad25c705ae82c5bc1ebe1edc0d9">&#9670;&nbsp;</a></span>operator=() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<div class="memtemplate">
template&lt;typename U , typename  = typename std::enable_if&lt;detail::result_is_value_assignable&lt;T,U&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">U &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt;  <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perfect-forwarded assignment. </p>
<p>Depending on whether <code>*this</code> contains a value before the call, the contained value is either direct-initialized from std::forward&lt;U&gt;(value) or assigned from std::forward&lt;U&gt;(value).</p>
<dl class="section note"><dt>Note</dt><dd>The function does not participate in overload resolution unless<ul>
<li><code>std::decay_t&lt;U&gt;</code> is not an result type,</li>
<li><code>std::decay_t&lt;U&gt;</code> is not an failure type</li>
<li><code>std::is_nothrow_constructible_v&lt;T, U&gt;</code> is <code>true</code></li>
<li><code>std::is_assignable_v&lt;T&amp;, U&gt;</code> is <code>true</code></li>
<li>and at least one of the following is <code>true</code>:<ul>
<li><code>T</code> is not a scalar type;</li>
<li><code>std::decay_t&lt;U&gt;</code> is not <code>T</code>.</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>to assign to the contained value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to <code>(*this)</code> </dd></dl>

</div>
</div>
<a id="aae159b2584abc4f61f055c60888dbee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae159b2584abc4f61f055c60888dbee0">&#9670;&nbsp;</a></span>operator=() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<div class="memtemplate">
template&lt;typename E2 , typename  = typename std::enable_if&lt;detail::result_is_failure_assignable&lt;E,const E2&amp;&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/dd0/classcpp_1_1bitwizeshift_1_1failure.html">failure</a>&lt; E2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const &amp; -&gt;  <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perfect-forwarded assignment. </p>
<p>Depending on whether <code>*this</code> contains a value before the call, the contained value is either direct-initialized from <code>std::forward&lt;U&gt;(value)</code> or assigned from <code>std::forward&lt;U&gt;(value)</code>.</p>
<dl class="section note"><dt>Note</dt><dd>The function does not participate in overload resolution unless<ul>
<li><code>std::is_nothrow_constructible_v&lt;E, E2&gt;</code> is <code>true</code></li>
<li><code>std::is_assignable_v&lt;T&amp;, U&gt;</code> is <code>true</code></li>
<li>and at least one of the following is true:<ul>
<li><code>T</code> is not a scalar type;</li>
<li><code>decay_t&lt;U&gt;</code> is not <code>T</code>.</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>to assign to the contained value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to <code>(*this)</code> </dd></dl>

</div>
</div>
<a id="ae3b72a65bedcf9ddabfab257d4873764"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3b72a65bedcf9ddabfab257d4873764">&#9670;&nbsp;</a></span>operator=() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<div class="memtemplate">
template&lt;typename E2 , typename  = typename std::enable_if&lt;detail::result_is_failure_assignable&lt;E,E2&amp;&amp;&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dd0/classcpp_1_1bitwizeshift_1_1failure.html">failure</a>&lt; E2 &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> &amp;&amp; -&gt;  <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perfect-forwarded assignment. </p>
<p>Depending on whether <code>*this</code> contains a value before the call, the contained value is either direct-initialized from <code>std::forward&lt;U&gt;(value)</code> or assigned from <code>std::forward&lt;U&gt;(value)</code>.</p>
<dl class="section note"><dt>Note</dt><dd>The function does not participate in overload resolution unless<ul>
<li><code>std::is_nothrow_constructible_v&lt;E, E2&gt;</code> is <code>true</code></li>
<li><code>std::is_assignable_v&lt;T&amp;, U&gt;</code> is <code>true</code></li>
<li>and at least one of the following is true:<ul>
<li><code>T</code> is not a scalar type;</li>
<li><code>decay_t&lt;U&gt;</code> is not <code>T</code>.</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>to assign to the contained value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to <code>(*this)</code> </dd></dl>

</div>
</div>
<a id="a09c4adf83dccbd85f85023eaadd93131"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c4adf83dccbd85f85023eaadd93131">&#9670;&nbsp;</a></span>value() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RESULT_CPP14_CONSTEXPR auto <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp; -&gt;  typename std::add_lvalue_reference&lt; T &gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the contained value. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../de/dac/classcpp_1_1bitwizeshift_1_1bad__result__access.html" title="An exception thrown when result::value is accessed without a contained value. ">bad_result_access</a></td><td>if <code>*this</code> does not contain a value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of <code>*this</code> </dd></dl>

</div>
</div>
<a id="a6ae66c7f04926ab5e5f7ad8fa411acf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ae66c7f04926ab5e5f7ad8fa411acf7">&#9670;&nbsp;</a></span>value() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RESULT_CPP14_CONSTEXPR auto <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;&amp; -&gt;  typename std::add_rvalue_reference&lt; T &gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the contained value. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../de/dac/classcpp_1_1bitwizeshift_1_1bad__result__access.html" title="An exception thrown when result::value is accessed without a contained value. ">bad_result_access</a></td><td>if <code>*this</code> does not contain a value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of <code>*this</code> </dd></dl>

</div>
</div>
<a id="aeefbda36edec6cf428b8bcb6045ea300"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeefbda36edec6cf428b8bcb6045ea300">&#9670;&nbsp;</a></span>value() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp; -&gt;  typename std::add_lvalue_reference&lt; typename std::add_const&lt; T &gt;::type &gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the contained value. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../de/dac/classcpp_1_1bitwizeshift_1_1bad__result__access.html" title="An exception thrown when result::value is accessed without a contained value. ">bad_result_access</a></td><td>if <code>*this</code> does not contain a value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of <code>*this</code> </dd></dl>

</div>
</div>
<a id="a970c87c3b07799bc73341abffc9e0943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a970c87c3b07799bc73341abffc9e0943">&#9670;&nbsp;</a></span>value() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;&amp; -&gt;  typename std::add_rvalue_reference&lt; typename std::add_const&lt; T &gt;::type &gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the contained value. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../de/dac/classcpp_1_1bitwizeshift_1_1bad__result__access.html" title="An exception thrown when result::value is accessed without a contained value. ">bad_result_access</a></td><td>if <code>*this</code> does not contain a value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of <code>*this</code> </dd></dl>

</div>
</div>
<a id="a54ed96521b164a8e28a531dea54e93c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54ed96521b164a8e28a531dea54e93c0">&#9670;&nbsp;</a></span>value_or() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::value_or </td>
          <td>(</td>
          <td class="paramtype">U &amp;&amp;&#160;</td>
          <td class="paramname"><em>default_value</em></td><td>)</td>
          <td> const &amp; -&gt;  typename std::remove_reference&lt; T &gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>} </p>
<p>Returns the contained value if <code>*this</code> has a value, otherwise returns <code>default_value</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">default_value</td><td>the value to use in case <code>*this</code> contains an error </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the contained value or <code>default_value</code> </dd></dl>

</div>
</div>
<a id="a78a9a3f8d66f7d17e3ab177b160838d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78a9a3f8d66f7d17e3ab177b160838d4">&#9670;&nbsp;</a></span>value_or() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RESULT_CPP14_CONSTEXPR auto <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::value_or </td>
          <td>(</td>
          <td class="paramtype">U &amp;&amp;&#160;</td>
          <td class="paramname"><em>default_value</em></td><td>)</td>
          <td> &amp;&amp; -&gt;  typename std::remove_reference&lt; T &gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the contained error, if one exists, or a default-constructed error value. </p>
<dl class="section return"><dt>Returns</dt><dd>the error or a default-constructed error value </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/<a class="el" href="../../de/d80/result_8hpp_source.html">result.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
 <!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
      <a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.png" alt="doxygen"></a>
    </li>
  </ul>
</div>
</body>
</html>