<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Result: cpp::bitwizeshift::result&lt; T, E &gt; Class Template Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Result
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('db/d9a/classcpp_1_1bitwizeshift_1_1result.html','../../');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="../../d1/d94/classcpp_1_1bitwizeshift_1_1result-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cpp::bitwizeshift::result&lt; T, E &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The class template <code>result</code> manages result results from APIs, while encoding possible failure conditions.  
 <a href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../de/d80/result_8hpp_source.html">result.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a31818816735f9d348e96cabad0559153"><td class="memItemLeft" align="right" valign="top"><a id="a31818816735f9d348e96cabad0559153"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a31818816735f9d348e96cabad0559153">value_type</a> = T</td></tr>
<tr class="memdesc:a31818816735f9d348e96cabad0559153"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value type of this result. <br /></td></tr>
<tr class="separator:a31818816735f9d348e96cabad0559153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf649f8e04fe1e24ffa827d2dbd1bbc1"><td class="memItemLeft" align="right" valign="top"><a id="acf649f8e04fe1e24ffa827d2dbd1bbc1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#acf649f8e04fe1e24ffa827d2dbd1bbc1">error_type</a> = E</td></tr>
<tr class="memdesc:acf649f8e04fe1e24ffa827d2dbd1bbc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The error type of this result. <br /></td></tr>
<tr class="separator:acf649f8e04fe1e24ffa827d2dbd1bbc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16ff7aef394eda8b170c43df2a7e12e4"><td class="memItemLeft" align="right" valign="top"><a id="a16ff7aef394eda8b170c43df2a7e12e4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a16ff7aef394eda8b170c43df2a7e12e4">failure_type</a> = <a class="el" href="../../dc/dd0/classcpp_1_1bitwizeshift_1_1failure.html">failure</a>&lt; E &gt;</td></tr>
<tr class="memdesc:a16ff7aef394eda8b170c43df2a7e12e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The failure type. <br /></td></tr>
<tr class="separator:a16ff7aef394eda8b170c43df2a7e12e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d94be75171a6eaaaa16ebbea8213c42"><td class="memTemplParams" colspan="2"><a id="a5d94be75171a6eaaaa16ebbea8213c42"></a>
template&lt;typename U &gt; </td></tr>
<tr class="memitem:a5d94be75171a6eaaaa16ebbea8213c42"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a5d94be75171a6eaaaa16ebbea8213c42">rebind</a> = <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a>&lt; U, E &gt;</td></tr>
<tr class="memdesc:a5d94be75171a6eaaaa16ebbea8213c42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rebinds the result type. <br /></td></tr>
<tr class="separator:a5d94be75171a6eaaaa16ebbea8213c42"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a294cc61375e0b4d0a0865f5477cff931"><td class="memTemplParams" colspan="2">template&lt;typename U  = T, typename  = typename std::enable_if&lt;std::is_constructible&lt;U&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a294cc61375e0b4d0a0865f5477cff931"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a294cc61375e0b4d0a0865f5477cff931">result</a> () noexcept(std::is_nothrow_constructible&lt; U &gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#ab3ba0d040afc7020329fcc840dcb855e">value</a>)</td></tr>
<tr class="memdesc:a294cc61375e0b4d0a0865f5477cff931"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default-constructs a result with the underlying value type active.  <a href="#a294cc61375e0b4d0a0865f5477cff931">More...</a><br /></td></tr>
<tr class="separator:a294cc61375e0b4d0a0865f5477cff931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6808ac32ce9de8acc667a3f9185ed14a"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a6808ac32ce9de8acc667a3f9185ed14a">result</a> (const <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a> &amp;other)=default</td></tr>
<tr class="memdesc:a6808ac32ce9de8acc667a3f9185ed14a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructs this result.  <a href="#a6808ac32ce9de8acc667a3f9185ed14a">More...</a><br /></td></tr>
<tr class="separator:a6808ac32ce9de8acc667a3f9185ed14a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a839b1bf77f5a92ff56c119d558bc98c7"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a839b1bf77f5a92ff56c119d558bc98c7">result</a> (<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a> &amp;&amp;other)=default</td></tr>
<tr class="memdesc:a839b1bf77f5a92ff56c119d558bc98c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructs a result.  <a href="#a839b1bf77f5a92ff56c119d558bc98c7">More...</a><br /></td></tr>
<tr class="separator:a839b1bf77f5a92ff56c119d558bc98c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e9c452ba7ab0130f0f4776aec66f49a"><td class="memTemplParams" colspan="2">template&lt;typename... Args, typename  = typename std::enable_if&lt;std::is_constructible&lt;T,Args...&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a3e9c452ba7ab0130f0f4776aec66f49a"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a3e9c452ba7ab0130f0f4776aec66f49a">result</a> (<a class="el" href="../../d0/d99/structcpp_1_1bitwizeshift_1_1in__place__t.html">in_place_t</a>, Args &amp;&amp;... args) noexcept(std::is_nothrow_constructible&lt; T, Args... &gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#ab3ba0d040afc7020329fcc840dcb855e">value</a>)</td></tr>
<tr class="memdesc:a3e9c452ba7ab0130f0f4776aec66f49a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a result object that contains a value.  <a href="#a3e9c452ba7ab0130f0f4776aec66f49a">More...</a><br /></td></tr>
<tr class="separator:a3e9c452ba7ab0130f0f4776aec66f49a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae126a3af750a64eec9ebe7b2325afe2"><td class="memTemplParams" colspan="2">template&lt;typename U , typename... Args, typename  = typename std::enable_if&lt;std::is_constructible&lt;T, std::initializer_list&lt;U&gt;&amp;, Args...&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:aae126a3af750a64eec9ebe7b2325afe2"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#aae126a3af750a64eec9ebe7b2325afe2">result</a> (<a class="el" href="../../d0/d99/structcpp_1_1bitwizeshift_1_1in__place__t.html">in_place_t</a>, std::initializer_list&lt; U &gt; ilist, Args &amp;&amp;...args) noexcept(std::is_nothrow_constructible&lt; T, std::initializer_list&lt; U &gt;, Args... &gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#ab3ba0d040afc7020329fcc840dcb855e">value</a>)</td></tr>
<tr class="memdesc:aae126a3af750a64eec9ebe7b2325afe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a result object that contains a value.  <a href="#aae126a3af750a64eec9ebe7b2325afe2">More...</a><br /></td></tr>
<tr class="separator:aae126a3af750a64eec9ebe7b2325afe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a691fbdb19ae0c4fb858aa8425c51d5de"><td class="memTemplParams" colspan="2">template&lt;typename... Args, typename  = typename std::enable_if&lt;std::is_constructible&lt;E,Args...&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a691fbdb19ae0c4fb858aa8425c51d5de"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a691fbdb19ae0c4fb858aa8425c51d5de">result</a> (<a class="el" href="../../d1/d00/structcpp_1_1bitwizeshift_1_1in__place__error__t.html">in_place_error_t</a>, Args &amp;&amp;... args) noexcept(std::is_nothrow_constructible&lt; E, Args... &gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#ab3ba0d040afc7020329fcc840dcb855e">value</a>)</td></tr>
<tr class="memdesc:a691fbdb19ae0c4fb858aa8425c51d5de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a result object that contains an error.  <a href="#a691fbdb19ae0c4fb858aa8425c51d5de">More...</a><br /></td></tr>
<tr class="separator:a691fbdb19ae0c4fb858aa8425c51d5de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59c7df8b675c1f7177b22a74da477f62"><td class="memTemplParams" colspan="2">template&lt;typename U , typename... Args, typename  = typename std::enable_if&lt;std::is_constructible&lt;E, std::initializer_list&lt;U&gt;&amp;, Args...&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a59c7df8b675c1f7177b22a74da477f62"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a59c7df8b675c1f7177b22a74da477f62">result</a> (<a class="el" href="../../d1/d00/structcpp_1_1bitwizeshift_1_1in__place__error__t.html">in_place_error_t</a>, std::initializer_list&lt; U &gt; ilist, Args &amp;&amp;...args) noexcept(std::is_nothrow_constructible&lt; E, std::initializer_list&lt; U &gt;, Args... &gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#ab3ba0d040afc7020329fcc840dcb855e">value</a>)</td></tr>
<tr class="memdesc:a59c7df8b675c1f7177b22a74da477f62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a result object that contains an error.  <a href="#a59c7df8b675c1f7177b22a74da477f62">More...</a><br /></td></tr>
<tr class="separator:a59c7df8b675c1f7177b22a74da477f62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5307dea65a0fd87bdcd48c70a6827b10"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a5307dea65a0fd87bdcd48c70a6827b10">operator=</a> (const <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a> &amp;other) -&gt; <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a> &amp;=default</td></tr>
<tr class="memdesc:a5307dea65a0fd87bdcd48c70a6827b10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assigns the result stored in <code>other</code>.  <a href="#a5307dea65a0fd87bdcd48c70a6827b10">More...</a><br /></td></tr>
<tr class="separator:a5307dea65a0fd87bdcd48c70a6827b10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7001dcd67ce0f053e77e70100fdc82e0"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a7001dcd67ce0f053e77e70100fdc82e0">operator=</a> (<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a> &amp;&amp;other) -&gt; <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a> &amp;=default</td></tr>
<tr class="memdesc:a7001dcd67ce0f053e77e70100fdc82e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assigns the result stored in <code>other</code>.  <a href="#a7001dcd67ce0f053e77e70100fdc82e0">More...</a><br /></td></tr>
<tr class="separator:a7001dcd67ce0f053e77e70100fdc82e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa0909f15e9e8b97cfdf89bc4e880176"><td class="memTemplParams" colspan="2">template&lt;typename T2 , typename E2 , typename  = typename std::enable_if&lt;detail::result_is_copy_convert_assignable&lt;T,E,T2,E2&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:afa0909f15e9e8b97cfdf89bc4e880176"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#afa0909f15e9e8b97cfdf89bc4e880176">operator=</a> (const <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a>&lt; T2, E2 &gt; &amp;other) noexcept(std::is_nothrow_assignable&lt; T, const T2 &amp;&gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#ab3ba0d040afc7020329fcc840dcb855e">value</a> &amp;&amp;std::is_nothrow_assignable&lt; E, const E2 &amp;&gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#ab3ba0d040afc7020329fcc840dcb855e">value</a>) -&gt; <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a> &amp;</td></tr>
<tr class="memdesc:afa0909f15e9e8b97cfdf89bc4e880176"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy-converts the state of <code>other</code>.  <a href="#afa0909f15e9e8b97cfdf89bc4e880176">More...</a><br /></td></tr>
<tr class="separator:afa0909f15e9e8b97cfdf89bc4e880176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7964841611e21dcdaa0c6ad324b65be"><td class="memTemplParams" colspan="2">template&lt;typename T2 , typename E2 , typename  = typename std::enable_if&lt;detail::result_is_move_convert_assignable&lt;T,E,T2,E2&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:aa7964841611e21dcdaa0c6ad324b65be"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#aa7964841611e21dcdaa0c6ad324b65be">operator=</a> (<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a>&lt; T2, E2 &gt; &amp;&amp;other) noexcept(std::is_nothrow_assignable&lt; T, T2 &amp;&amp;&gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#ab3ba0d040afc7020329fcc840dcb855e">value</a> &amp;&amp;std::is_nothrow_assignable&lt; E, E2 &amp;&amp;&gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#ab3ba0d040afc7020329fcc840dcb855e">value</a>) -&gt; <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a> &amp;</td></tr>
<tr class="memdesc:aa7964841611e21dcdaa0c6ad324b65be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-converts the state of <code>other</code>.  <a href="#aa7964841611e21dcdaa0c6ad324b65be">More...</a><br /></td></tr>
<tr class="separator:aa7964841611e21dcdaa0c6ad324b65be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedce2ad25c705ae82c5bc1ebe1edc0d9"><td class="memTemplParams" colspan="2">template&lt;typename U , typename  = typename std::enable_if&lt;detail::result_is_value_assignable&lt;T,U&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:aedce2ad25c705ae82c5bc1ebe1edc0d9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#aedce2ad25c705ae82c5bc1ebe1edc0d9">operator=</a> (U &amp;&amp;<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#ab3ba0d040afc7020329fcc840dcb855e">value</a>) noexcept(std::is_nothrow_assignable&lt; T, U &gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#ab3ba0d040afc7020329fcc840dcb855e">value</a>) -&gt; <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a> &amp;</td></tr>
<tr class="memdesc:aedce2ad25c705ae82c5bc1ebe1edc0d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perfect-forwarded assignment.  <a href="#aedce2ad25c705ae82c5bc1ebe1edc0d9">More...</a><br /></td></tr>
<tr class="separator:aedce2ad25c705ae82c5bc1ebe1edc0d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc91910d9e3ad9dcfccd26e8500a02db"><td class="memItemLeft" align="right" valign="top">RESULT_WARN_UNUSED constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#afc91910d9e3ad9dcfccd26e8500a02db">operator bool</a> () const noexcept</td></tr>
<tr class="memdesc:afc91910d9e3ad9dcfccd26e8500a02db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contextually convertible to <code>true</code> if <code>*this</code> contains a value.  <a href="#afc91910d9e3ad9dcfccd26e8500a02db">More...</a><br /></td></tr>
<tr class="separator:afc91910d9e3ad9dcfccd26e8500a02db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e6e79bb2df85cf71375a366cd03c17a"><td class="memItemLeft" align="right" valign="top">RESULT_WARN_UNUSED constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a4e6e79bb2df85cf71375a366cd03c17a">has_value</a> () const noexcept -&gt; bool</td></tr>
<tr class="memdesc:a4e6e79bb2df85cf71375a366cd03c17a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if <code>*this</code> contains a value.  <a href="#a4e6e79bb2df85cf71375a366cd03c17a">More...</a><br /></td></tr>
<tr class="separator:a4e6e79bb2df85cf71375a366cd03c17a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13104666eb498cf58c91fcd22ac6ad89"><td class="memItemLeft" align="right" valign="top">RESULT_WARN_UNUSED constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a13104666eb498cf58c91fcd22ac6ad89">has_error</a> () const noexcept -&gt; bool</td></tr>
<tr class="memdesc:a13104666eb498cf58c91fcd22ac6ad89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if <code>*this</code> contains an error.  <a href="#a13104666eb498cf58c91fcd22ac6ad89">More...</a><br /></td></tr>
<tr class="separator:a13104666eb498cf58c91fcd22ac6ad89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa741ce67edc24d27a5f58cc16e1e214d"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:aa741ce67edc24d27a5f58cc16e1e214d"><td class="memTemplItemLeft" align="right" valign="top">RESULT_WARN_UNUSED constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#aa741ce67edc24d27a5f58cc16e1e214d">and_then</a> (U &amp;&amp;<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#ab3ba0d040afc7020329fcc840dcb855e">value</a>) const -&gt; <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a>&lt; typename std::decay&lt; U &gt;::type, E &gt;</td></tr>
<tr class="memdesc:aa741ce67edc24d27a5f58cc16e1e214d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a result containing <code>value</code> if this result contains a value, otherwise returns a result containing the current error.  <a href="#aa741ce67edc24d27a5f58cc16e1e214d">More...</a><br /></td></tr>
<tr class="separator:aa741ce67edc24d27a5f58cc16e1e214d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a376f846df51982f34e3ec3f952c39f80"><td class="memTemplParams" colspan="2">template&lt;typename T2 , typename E2 , typename std::enable_if&lt; detail::result_is_implicit_copy_convertible&lt; T, E, T2, E2 &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a376f846df51982f34e3ec3f952c39f80"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a376f846df51982f34e3ec3f952c39f80">result</a> (const <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a>&lt; T2, E2 &gt; &amp;other) noexcept(std::is_nothrow_constructible&lt; T, const T2 &amp;&gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#ab3ba0d040afc7020329fcc840dcb855e">value</a> &amp;&amp;std::is_nothrow_constructible&lt; E, const E2 &amp;&gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#ab3ba0d040afc7020329fcc840dcb855e">value</a>)</td></tr>
<tr class="memdesc:a376f846df51982f34e3ec3f952c39f80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converting copy constructor.  <a href="#a376f846df51982f34e3ec3f952c39f80">More...</a><br /></td></tr>
<tr class="separator:a376f846df51982f34e3ec3f952c39f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a376f846df51982f34e3ec3f952c39f80"><td class="memTemplParams" colspan="2">template&lt;typename T2 , typename E2 , typename std::enable_if&lt; detail::result_is_explicit_copy_convertible&lt; T, E, T2, E2 &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a376f846df51982f34e3ec3f952c39f80"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a376f846df51982f34e3ec3f952c39f80">result</a> (const <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a>&lt; T2, E2 &gt; &amp;other) noexcept(std::is_nothrow_constructible&lt; T, const T2 &amp;&gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#ab3ba0d040afc7020329fcc840dcb855e">value</a> &amp;&amp;std::is_nothrow_constructible&lt; E, const E2 &amp;&gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#ab3ba0d040afc7020329fcc840dcb855e">value</a>)</td></tr>
<tr class="memdesc:a376f846df51982f34e3ec3f952c39f80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converting copy constructor.  <a href="#a376f846df51982f34e3ec3f952c39f80">More...</a><br /></td></tr>
<tr class="separator:a376f846df51982f34e3ec3f952c39f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a1077f5f78da88859f109ff2b2756a0e1"><td class="memTemplParams" colspan="2">template&lt;typename T2 , typename E2 , typename std::enable_if&lt; detail::result_is_implicit_move_convertible&lt; T, E, T2, E2 &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a1077f5f78da88859f109ff2b2756a0e1"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a1077f5f78da88859f109ff2b2756a0e1">result</a> (<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a>&lt; T2, E2 &gt; &amp;&amp;other) noexcept(std::is_nothrow_constructible&lt; T, T2 &amp;&amp;&gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#ab3ba0d040afc7020329fcc840dcb855e">value</a> &amp;&amp;std::is_nothrow_constructible&lt; E, E2 &amp;&amp;&gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#ab3ba0d040afc7020329fcc840dcb855e">value</a>)</td></tr>
<tr class="memdesc:a1077f5f78da88859f109ff2b2756a0e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converting move constructor.  <a href="#a1077f5f78da88859f109ff2b2756a0e1">More...</a><br /></td></tr>
<tr class="separator:a1077f5f78da88859f109ff2b2756a0e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1077f5f78da88859f109ff2b2756a0e1"><td class="memTemplParams" colspan="2">template&lt;typename T2 , typename E2 , typename std::enable_if&lt; detail::result_is_explicit_move_convertible&lt; T, E, T2, E2 &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a1077f5f78da88859f109ff2b2756a0e1"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a1077f5f78da88859f109ff2b2756a0e1">result</a> (<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a>&lt; T2, E2 &gt; &amp;&amp;other) noexcept(std::is_nothrow_constructible&lt; T, T2 &amp;&amp;&gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#ab3ba0d040afc7020329fcc840dcb855e">value</a> &amp;&amp;std::is_nothrow_constructible&lt; E, E2 &amp;&amp;&gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#ab3ba0d040afc7020329fcc840dcb855e">value</a>)</td></tr>
<tr class="memdesc:a1077f5f78da88859f109ff2b2756a0e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converting move constructor.  <a href="#a1077f5f78da88859f109ff2b2756a0e1">More...</a><br /></td></tr>
<tr class="separator:a1077f5f78da88859f109ff2b2756a0e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aeb12608ba169d73dcac5204aefe5adb3"><td class="memTemplParams" colspan="2">template&lt;typename E2 , typename  = typename std::enable_if&lt;std::is_constructible&lt;E,const E2&amp;&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:aeb12608ba169d73dcac5204aefe5adb3"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#aeb12608ba169d73dcac5204aefe5adb3">result</a> (const <a class="el" href="../../dc/dd0/classcpp_1_1bitwizeshift_1_1failure.html">failure</a>&lt; E2 &gt; &amp;e) noexcept(std::is_nothrow_constructible&lt; E, const E2 &amp;&gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#ab3ba0d040afc7020329fcc840dcb855e">value</a>)</td></tr>
<tr class="memdesc:aeb12608ba169d73dcac5204aefe5adb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the underlying error of this result.  <a href="#aeb12608ba169d73dcac5204aefe5adb3">More...</a><br /></td></tr>
<tr class="separator:aeb12608ba169d73dcac5204aefe5adb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3361d2b8a668de4335fada30b1c3d9b3"><td class="memTemplParams" colspan="2">template&lt;typename E2 , typename  = typename std::enable_if&lt;std::is_constructible&lt;E,E2&amp;&amp;&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a3361d2b8a668de4335fada30b1c3d9b3"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a3361d2b8a668de4335fada30b1c3d9b3">result</a> (<a class="el" href="../../dc/dd0/classcpp_1_1bitwizeshift_1_1failure.html">failure</a>&lt; E2 &gt; &amp;&amp;e) noexcept(std::is_nothrow_constructible&lt; E, E2 &amp;&amp;&gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#ab3ba0d040afc7020329fcc840dcb855e">value</a>)</td></tr>
<tr class="memdesc:a3361d2b8a668de4335fada30b1c3d9b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the underlying error of this result.  <a href="#a3361d2b8a668de4335fada30b1c3d9b3">More...</a><br /></td></tr>
<tr class="separator:a3361d2b8a668de4335fada30b1c3d9b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a32a98dddc040fe525855b443115167e8"><td class="memTemplParams" colspan="2">template&lt;typename U , typename std::enable_if&lt; detail::result_is_explicit_value_convertible&lt; T, U &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a32a98dddc040fe525855b443115167e8"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a32a98dddc040fe525855b443115167e8">result</a> (U &amp;&amp;<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#ab3ba0d040afc7020329fcc840dcb855e">value</a>) noexcept(std::is_nothrow_constructible&lt; T, U &gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#ab3ba0d040afc7020329fcc840dcb855e">value</a>)</td></tr>
<tr class="memdesc:a32a98dddc040fe525855b443115167e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a result object that contains a value.  <a href="#a32a98dddc040fe525855b443115167e8">More...</a><br /></td></tr>
<tr class="separator:a32a98dddc040fe525855b443115167e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32a98dddc040fe525855b443115167e8"><td class="memTemplParams" colspan="2">template&lt;typename U , typename std::enable_if&lt; detail::result_is_implicit_value_convertible&lt; T, U &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a32a98dddc040fe525855b443115167e8"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a32a98dddc040fe525855b443115167e8">result</a> (U &amp;&amp;<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#ab3ba0d040afc7020329fcc840dcb855e">value</a>) noexcept(std::is_nothrow_constructible&lt; T, U &gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#ab3ba0d040afc7020329fcc840dcb855e">value</a>)</td></tr>
<tr class="memdesc:a32a98dddc040fe525855b443115167e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a result object that contains a value.  <a href="#a32a98dddc040fe525855b443115167e8">More...</a><br /></td></tr>
<tr class="separator:a32a98dddc040fe525855b443115167e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aae159b2584abc4f61f055c60888dbee0"><td class="memTemplParams" colspan="2">template&lt;typename E2 , typename  = typename std::enable_if&lt;detail::result_is_failure_assignable&lt;E,const E2&amp;&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:aae159b2584abc4f61f055c60888dbee0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#aae159b2584abc4f61f055c60888dbee0">operator=</a> (const <a class="el" href="../../dc/dd0/classcpp_1_1bitwizeshift_1_1failure.html">failure</a>&lt; E2 &gt; &amp;other) noexcept(std::is_nothrow_assignable&lt; E, const E2 &amp;&gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#ab3ba0d040afc7020329fcc840dcb855e">value</a>) -&gt; <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a> &amp;</td></tr>
<tr class="memdesc:aae159b2584abc4f61f055c60888dbee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perfect-forwarded assignment.  <a href="#aae159b2584abc4f61f055c60888dbee0">More...</a><br /></td></tr>
<tr class="separator:aae159b2584abc4f61f055c60888dbee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3b72a65bedcf9ddabfab257d4873764"><td class="memTemplParams" colspan="2">template&lt;typename E2 , typename  = typename std::enable_if&lt;detail::result_is_failure_assignable&lt;E,E2&amp;&amp;&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:ae3b72a65bedcf9ddabfab257d4873764"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#ae3b72a65bedcf9ddabfab257d4873764">operator=</a> (<a class="el" href="../../dc/dd0/classcpp_1_1bitwizeshift_1_1failure.html">failure</a>&lt; E2 &gt; &amp;&amp;other) noexcept(std::is_nothrow_assignable&lt; E, E2 &amp;&amp;&gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#ab3ba0d040afc7020329fcc840dcb855e">value</a>) -&gt; <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a> &amp;</td></tr>
<tr class="memdesc:ae3b72a65bedcf9ddabfab257d4873764"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perfect-forwarded assignment.  <a href="#ae3b72a65bedcf9ddabfab257d4873764">More...</a><br /></td></tr>
<tr class="separator:ae3b72a65bedcf9ddabfab257d4873764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a94ee155e428aae07e77869e5f8fe64fd"><td class="memItemLeft" align="right" valign="top">RESULT_WARN_UNUSED RESULT_CPP14_CONSTEXPR auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a94ee155e428aae07e77869e5f8fe64fd">operator-&gt;</a> () noexcept -&gt; typename std::remove_reference&lt; T &gt;::type *</td></tr>
<tr class="memdesc:a94ee155e428aae07e77869e5f8fe64fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a pointer to the contained value.  <a href="#a94ee155e428aae07e77869e5f8fe64fd">More...</a><br /></td></tr>
<tr class="separator:a94ee155e428aae07e77869e5f8fe64fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeff84a441f2b92f5f555421f56eec30c"><td class="memItemLeft" align="right" valign="top">RESULT_WARN_UNUSED constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#aeff84a441f2b92f5f555421f56eec30c">operator-&gt;</a> () const noexcept -&gt; typename std::remove_reference&lt; typename std::add_const&lt; T &gt;::type &gt;::type *</td></tr>
<tr class="memdesc:aeff84a441f2b92f5f555421f56eec30c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a pointer to the contained value.  <a href="#aeff84a441f2b92f5f555421f56eec30c">More...</a><br /></td></tr>
<tr class="separator:aeff84a441f2b92f5f555421f56eec30c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a4c42b8a7ea621f5559a296cc131ce645"><td class="memItemLeft" align="right" valign="top">RESULT_WARN_UNUSED RESULT_CPP14_CONSTEXPR auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a4c42b8a7ea621f5559a296cc131ce645">operator*</a> () &amp;noexcept -&gt; typename std::add_lvalue_reference&lt; T &gt;::type</td></tr>
<tr class="memdesc:a4c42b8a7ea621f5559a296cc131ce645"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a reference to the contained value.  <a href="#a4c42b8a7ea621f5559a296cc131ce645">More...</a><br /></td></tr>
<tr class="separator:a4c42b8a7ea621f5559a296cc131ce645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69f0b45ab457c1a90345cb908c5d6c56"><td class="memItemLeft" align="right" valign="top">RESULT_WARN_UNUSED RESULT_CPP14_CONSTEXPR auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a69f0b45ab457c1a90345cb908c5d6c56">operator*</a> () &amp;&amp;noexcept -&gt; typename std::add_rvalue_reference&lt; T &gt;::type</td></tr>
<tr class="memdesc:a69f0b45ab457c1a90345cb908c5d6c56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a reference to the contained value.  <a href="#a69f0b45ab457c1a90345cb908c5d6c56">More...</a><br /></td></tr>
<tr class="separator:a69f0b45ab457c1a90345cb908c5d6c56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d9c1a1a43982dfaae4abda97c7f53a2"><td class="memItemLeft" align="right" valign="top">RESULT_WARN_UNUSED constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a3d9c1a1a43982dfaae4abda97c7f53a2">operator*</a> () const &amp;noexcept -&gt; typename std::add_lvalue_reference&lt; typename std::add_const&lt; T &gt;::type &gt;::type</td></tr>
<tr class="memdesc:a3d9c1a1a43982dfaae4abda97c7f53a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a reference to the contained value.  <a href="#a3d9c1a1a43982dfaae4abda97c7f53a2">More...</a><br /></td></tr>
<tr class="separator:a3d9c1a1a43982dfaae4abda97c7f53a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4fb55a264f599d613776620cc2d793f"><td class="memItemLeft" align="right" valign="top">RESULT_WARN_UNUSED constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#ab4fb55a264f599d613776620cc2d793f">operator*</a> () const &amp;&amp;noexcept -&gt; typename std::add_rvalue_reference&lt; typename std::add_const&lt; T &gt;::type &gt;::type</td></tr>
<tr class="memdesc:ab4fb55a264f599d613776620cc2d793f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a reference to the contained value.  <a href="#ab4fb55a264f599d613776620cc2d793f">More...</a><br /></td></tr>
<tr class="separator:ab4fb55a264f599d613776620cc2d793f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ab3ba0d040afc7020329fcc840dcb855e"><td class="memItemLeft" align="right" valign="top">RESULT_WARN_UNUSED RESULT_CPP14_CONSTEXPR auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#ab3ba0d040afc7020329fcc840dcb855e">value</a> () &amp;-&gt; typename std::add_lvalue_reference&lt; T &gt;::type</td></tr>
<tr class="memdesc:ab3ba0d040afc7020329fcc840dcb855e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the contained value.  <a href="#ab3ba0d040afc7020329fcc840dcb855e">More...</a><br /></td></tr>
<tr class="separator:ab3ba0d040afc7020329fcc840dcb855e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab18037be1f183edc5fda0a819f2a1ecd"><td class="memItemLeft" align="right" valign="top">RESULT_WARN_UNUSED RESULT_CPP14_CONSTEXPR auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#ab18037be1f183edc5fda0a819f2a1ecd">value</a> () &amp;&amp;-&gt; typename std::add_rvalue_reference&lt; T &gt;::type</td></tr>
<tr class="memdesc:ab18037be1f183edc5fda0a819f2a1ecd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the contained value.  <a href="#ab18037be1f183edc5fda0a819f2a1ecd">More...</a><br /></td></tr>
<tr class="separator:ab18037be1f183edc5fda0a819f2a1ecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c301c005ed696c904f017e6c69fbae2"><td class="memItemLeft" align="right" valign="top">RESULT_WARN_UNUSED constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a4c301c005ed696c904f017e6c69fbae2">value</a> () const &amp;-&gt; typename std::add_lvalue_reference&lt; typename std::add_const&lt; T &gt;::type &gt;::type</td></tr>
<tr class="memdesc:a4c301c005ed696c904f017e6c69fbae2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the contained value.  <a href="#a4c301c005ed696c904f017e6c69fbae2">More...</a><br /></td></tr>
<tr class="separator:a4c301c005ed696c904f017e6c69fbae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96ce9e22e0ff3041a45c1ad213d27e7b"><td class="memItemLeft" align="right" valign="top">RESULT_WARN_UNUSED constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a96ce9e22e0ff3041a45c1ad213d27e7b">value</a> () const &amp;&amp;-&gt; typename std::add_rvalue_reference&lt; typename std::add_const&lt; T &gt;::type &gt;::type</td></tr>
<tr class="memdesc:a96ce9e22e0ff3041a45c1ad213d27e7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the contained value.  <a href="#a96ce9e22e0ff3041a45c1ad213d27e7b">More...</a><br /></td></tr>
<tr class="separator:a96ce9e22e0ff3041a45c1ad213d27e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ac1a6da3db72049f2ef3e916e69a93735"><td class="memItemLeft" align="right" valign="top">RESULT_WARN_UNUSED constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#ac1a6da3db72049f2ef3e916e69a93735">error</a> () const &amp;noexcept(std::is_nothrow_constructible&lt; E &gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#ab3ba0d040afc7020329fcc840dcb855e">value</a> &amp;&amp;std::is_nothrow_copy_constructible&lt; E &gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#ab3ba0d040afc7020329fcc840dcb855e">value</a>) -&gt; E</td></tr>
<tr class="memdesc:ac1a6da3db72049f2ef3e916e69a93735"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the contained error, if one exists, or a default-constructed error value.  <a href="#ac1a6da3db72049f2ef3e916e69a93735">More...</a><br /></td></tr>
<tr class="separator:ac1a6da3db72049f2ef3e916e69a93735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35676e4f60e0aab8f705caec8fe86620"><td class="memItemLeft" align="right" valign="top">RESULT_WARN_UNUSED RESULT_CPP14_CONSTEXPR auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a35676e4f60e0aab8f705caec8fe86620">error</a> () &amp;&amp;noexcept(std::is_nothrow_constructible&lt; E &gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#ab3ba0d040afc7020329fcc840dcb855e">value</a> &amp;&amp;std::is_nothrow_move_constructible&lt; E &gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#ab3ba0d040afc7020329fcc840dcb855e">value</a>) -&gt; E</td></tr>
<tr class="memdesc:a35676e4f60e0aab8f705caec8fe86620"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the contained error, if one exists, or a default-constructed error value.  <a href="#a35676e4f60e0aab8f705caec8fe86620">More...</a><br /></td></tr>
<tr class="separator:a35676e4f60e0aab8f705caec8fe86620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff9d84e6e09ccfab440166b4ef1a7766"><td class="memTemplParams" colspan="2">template&lt;typename String , typename  = typename std::enable_if&lt;(                std::is_convertible&lt;String,const std::string&amp;&gt;::value &amp;&amp;                std::is_copy_constructible&lt;E&gt;::value              )&gt;::type&gt; </td></tr>
<tr class="memitem:aff9d84e6e09ccfab440166b4ef1a7766"><td class="memTemplItemLeft" align="right" valign="top">RESULT_CPP14_CONSTEXPR auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#aff9d84e6e09ccfab440166b4ef1a7766">expect</a> (String &amp;&amp;message) const &amp;-&gt; void</td></tr>
<tr class="memdesc:aff9d84e6e09ccfab440166b4ef1a7766"><td class="mdescLeft">&#160;</td><td class="mdescRight">}  <a href="#aff9d84e6e09ccfab440166b4ef1a7766">More...</a><br /></td></tr>
<tr class="separator:aff9d84e6e09ccfab440166b4ef1a7766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfc85857bc1cbd4098a3ec7587176abc"><td class="memTemplParams" colspan="2">template&lt;typename String , typename  = typename std::enable_if&lt;(                std::is_convertible&lt;String,const std::string&amp;&gt;::value &amp;&amp;                std::is_move_constructible&lt;E&gt;::value              )&gt;::type&gt; </td></tr>
<tr class="memitem:abfc85857bc1cbd4098a3ec7587176abc"><td class="memTemplItemLeft" align="right" valign="top">RESULT_CPP14_CONSTEXPR auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#abfc85857bc1cbd4098a3ec7587176abc">expect</a> (String &amp;&amp;message) &amp;&amp;-&gt; void</td></tr>
<tr class="memdesc:abfc85857bc1cbd4098a3ec7587176abc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the contained error, if one exists, or a default-constructed error value.  <a href="#abfc85857bc1cbd4098a3ec7587176abc">More...</a><br /></td></tr>
<tr class="separator:abfc85857bc1cbd4098a3ec7587176abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a940d1ef3f46c158696db5f4f0c47440d"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a940d1ef3f46c158696db5f4f0c47440d"><td class="memTemplItemLeft" align="right" valign="top">RESULT_WARN_UNUSED constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a940d1ef3f46c158696db5f4f0c47440d">value_or</a> (U &amp;&amp;default_value) const &amp;-&gt; typename std::remove_reference&lt; T &gt;::type</td></tr>
<tr class="memdesc:a940d1ef3f46c158696db5f4f0c47440d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the contained value if <code>*this</code> has a value, otherwise returns <code>default_value</code>.  <a href="#a940d1ef3f46c158696db5f4f0c47440d">More...</a><br /></td></tr>
<tr class="separator:a940d1ef3f46c158696db5f4f0c47440d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86ecfa9df078e95b21e7ceed021e12db"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a86ecfa9df078e95b21e7ceed021e12db"><td class="memTemplItemLeft" align="right" valign="top">RESULT_WARN_UNUSED RESULT_CPP14_CONSTEXPR auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a86ecfa9df078e95b21e7ceed021e12db">value_or</a> (U &amp;&amp;default_value) &amp;&amp;-&gt; typename std::remove_reference&lt; T &gt;::type</td></tr>
<tr class="memdesc:a86ecfa9df078e95b21e7ceed021e12db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the contained value if <code>*this</code> has a value, otherwise returns <code>default_value</code>.  <a href="#a86ecfa9df078e95b21e7ceed021e12db">More...</a><br /></td></tr>
<tr class="separator:a86ecfa9df078e95b21e7ceed021e12db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a0b1f8f312619e37594054f94a283a48f"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a0b1f8f312619e37594054f94a283a48f"><td class="memTemplItemLeft" align="right" valign="top">RESULT_WARN_UNUSED constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a0b1f8f312619e37594054f94a283a48f">error_or</a> (U &amp;&amp;default_error) const &amp;-&gt; <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#acf649f8e04fe1e24ffa827d2dbd1bbc1">error_type</a></td></tr>
<tr class="memdesc:a0b1f8f312619e37594054f94a283a48f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the contained error if <code>*this</code> has an error, otherwise returns <code>default_error</code>.  <a href="#a0b1f8f312619e37594054f94a283a48f">More...</a><br /></td></tr>
<tr class="separator:a0b1f8f312619e37594054f94a283a48f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab56c3d217a7fc14c8e33425192cd9aa0"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:ab56c3d217a7fc14c8e33425192cd9aa0"><td class="memTemplItemLeft" align="right" valign="top">RESULT_WARN_UNUSED RESULT_CPP14_CONSTEXPR auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#ab56c3d217a7fc14c8e33425192cd9aa0">error_or</a> (U &amp;&amp;default_error) &amp;&amp;-&gt; <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#acf649f8e04fe1e24ffa827d2dbd1bbc1">error_type</a></td></tr>
<tr class="memdesc:ab56c3d217a7fc14c8e33425192cd9aa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the contained error if <code>*this</code> has an error, otherwise returns <code>default_error</code>.  <a href="#ab56c3d217a7fc14c8e33425192cd9aa0">More...</a><br /></td></tr>
<tr class="separator:ab56c3d217a7fc14c8e33425192cd9aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a516eda185e20c05b1290def23b80155c"><td class="memTemplParams" colspan="2">template&lt;typename Fn &gt; </td></tr>
<tr class="memitem:a516eda185e20c05b1290def23b80155c"><td class="memTemplItemLeft" align="right" valign="top">RESULT_WARN_UNUSED constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a516eda185e20c05b1290def23b80155c">flat_map</a> (Fn &amp;&amp;fn) const &amp;-&gt; detail::invoke_result_t&lt; Fn, const T &amp;&gt;</td></tr>
<tr class="memdesc:a516eda185e20c05b1290def23b80155c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes the function <code>fn</code> with the value of this result as the argument.  <a href="#a516eda185e20c05b1290def23b80155c">More...</a><br /></td></tr>
<tr class="separator:a516eda185e20c05b1290def23b80155c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a136350853506e48fe93e4e1f44c389fe"><td class="memTemplParams" colspan="2">template&lt;typename Fn &gt; </td></tr>
<tr class="memitem:a136350853506e48fe93e4e1f44c389fe"><td class="memTemplItemLeft" align="right" valign="top">RESULT_WARN_UNUSED RESULT_CPP14_CONSTEXPR auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a136350853506e48fe93e4e1f44c389fe">flat_map</a> (Fn &amp;&amp;fn) &amp;&amp;-&gt; detail::invoke_result_t&lt; Fn, T &amp;&amp;&gt;</td></tr>
<tr class="memdesc:a136350853506e48fe93e4e1f44c389fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes the function <code>fn</code> with the value of this result as the argument.  <a href="#a136350853506e48fe93e4e1f44c389fe">More...</a><br /></td></tr>
<tr class="separator:a136350853506e48fe93e4e1f44c389fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a4021b0883f546564e3474f7ead6d682b"><td class="memTemplParams" colspan="2">template&lt;typename Fn &gt; </td></tr>
<tr class="memitem:a4021b0883f546564e3474f7ead6d682b"><td class="memTemplItemLeft" align="right" valign="top">RESULT_WARN_UNUSED constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a4021b0883f546564e3474f7ead6d682b">map</a> (Fn &amp;&amp;fn) const &amp;-&gt; <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a>&lt; detail::invoke_result_t&lt; Fn, const T &amp;&gt;, E &gt;</td></tr>
<tr class="memdesc:a4021b0883f546564e3474f7ead6d682b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes the function <code>fn</code> with the value of this result as the argument.  <a href="#a4021b0883f546564e3474f7ead6d682b">More...</a><br /></td></tr>
<tr class="separator:a4021b0883f546564e3474f7ead6d682b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab92526f21d8f2e9b991bd212d3b63965"><td class="memTemplParams" colspan="2">template&lt;typename Fn &gt; </td></tr>
<tr class="memitem:ab92526f21d8f2e9b991bd212d3b63965"><td class="memTemplItemLeft" align="right" valign="top">RESULT_WARN_UNUSED RESULT_CPP14_CONSTEXPR auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#ab92526f21d8f2e9b991bd212d3b63965">map</a> (Fn &amp;&amp;fn) &amp;&amp;-&gt; <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a>&lt; detail::invoke_result_t&lt; Fn, T &amp;&amp;&gt;, E &gt;</td></tr>
<tr class="memdesc:ab92526f21d8f2e9b991bd212d3b63965"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes the function <code>fn</code> with the value of this result as the argument.  <a href="#ab92526f21d8f2e9b991bd212d3b63965">More...</a><br /></td></tr>
<tr class="separator:ab92526f21d8f2e9b991bd212d3b63965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ab91bca764d3ef5fb26a83a2da683dc4e"><td class="memTemplParams" colspan="2">template&lt;typename Fn &gt; </td></tr>
<tr class="memitem:ab91bca764d3ef5fb26a83a2da683dc4e"><td class="memTemplItemLeft" align="right" valign="top">RESULT_WARN_UNUSED constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#ab91bca764d3ef5fb26a83a2da683dc4e">map_error</a> (Fn &amp;&amp;fn) const &amp;-&gt; <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a>&lt; T, detail::invoke_result_t&lt; Fn, const E &amp;&gt;&gt;</td></tr>
<tr class="memdesc:ab91bca764d3ef5fb26a83a2da683dc4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes the function <code>fn</code> with the error of this result as the argument.  <a href="#ab91bca764d3ef5fb26a83a2da683dc4e">More...</a><br /></td></tr>
<tr class="separator:ab91bca764d3ef5fb26a83a2da683dc4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70f80dcc9dcd3527a7c2aa72e09885b9"><td class="memTemplParams" colspan="2">template&lt;typename Fn &gt; </td></tr>
<tr class="memitem:a70f80dcc9dcd3527a7c2aa72e09885b9"><td class="memTemplItemLeft" align="right" valign="top">RESULT_WARN_UNUSED RESULT_CPP14_CONSTEXPR auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a70f80dcc9dcd3527a7c2aa72e09885b9">map_error</a> (Fn &amp;&amp;fn) &amp;&amp;-&gt; <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a>&lt; T, detail::invoke_result_t&lt; Fn, E &amp;&amp;&gt;&gt;</td></tr>
<tr class="memdesc:a70f80dcc9dcd3527a7c2aa72e09885b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes the function <code>fn</code> with the error of this result as the argument.  <a href="#a70f80dcc9dcd3527a7c2aa72e09885b9">More...</a><br /></td></tr>
<tr class="separator:a70f80dcc9dcd3527a7c2aa72e09885b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a820ce0afdea9a7bfa1be9d6fdb14d308"><td class="memTemplParams" colspan="2">template&lt;typename Fn &gt; </td></tr>
<tr class="memitem:a820ce0afdea9a7bfa1be9d6fdb14d308"><td class="memTemplItemLeft" align="right" valign="top">RESULT_WARN_UNUSED constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a820ce0afdea9a7bfa1be9d6fdb14d308">flat_map_error</a> (Fn &amp;&amp;fn) const &amp;-&gt; detail::invoke_result_t&lt; Fn, const E &amp;&gt;</td></tr>
<tr class="memdesc:a820ce0afdea9a7bfa1be9d6fdb14d308"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes the function <code>fn</code> with the error of this result as the argument.  <a href="#a820ce0afdea9a7bfa1be9d6fdb14d308">More...</a><br /></td></tr>
<tr class="separator:a820ce0afdea9a7bfa1be9d6fdb14d308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d7bbcddb8d25a04905852eb6e3bade"><td class="memTemplParams" colspan="2">template&lt;typename Fn &gt; </td></tr>
<tr class="memitem:a90d7bbcddb8d25a04905852eb6e3bade"><td class="memTemplItemLeft" align="right" valign="top">RESULT_WARN_UNUSED RESULT_CPP14_CONSTEXPR auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a90d7bbcddb8d25a04905852eb6e3bade">flat_map_error</a> (Fn &amp;&amp;fn) &amp;&amp;-&gt; detail::invoke_result_t&lt; Fn, E &amp;&amp;&gt;</td></tr>
<tr class="memdesc:a90d7bbcddb8d25a04905852eb6e3bade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes the function <code>fn</code> with the error of this result as the argument.  <a href="#a90d7bbcddb8d25a04905852eb6e3bade">More...</a><br /></td></tr>
<tr class="separator:a90d7bbcddb8d25a04905852eb6e3bade"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a65d3ad0b808ae578a08ec9cde8a6adac"><td class="memTemplParams" colspan="2"><a id="a65d3ad0b808ae578a08ec9cde8a6adac"></a>
template&lt;typename T2 , typename E2 &gt; </td></tr>
<tr class="memitem:a65d3ad0b808ae578a08ec9cde8a6adac"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>result</b></td></tr>
<tr class="separator:a65d3ad0b808ae578a08ec9cde8a6adac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, typename E&gt;<br />
class cpp::bitwizeshift::result&lt; T, E &gt;</h3>

<p>The class template <code>result</code> manages result results from APIs, while encoding possible failure conditions. </p>
<p>A common use-case for result is the return value of a function that may fail. As opposed to other approaches, such as <code>std::pair&lt;T,bool&gt;</code> or <code>std::optional</code>, <code>result</code> more accurately conveys the intent of the user along with the failure condition to the caller. This effectively produces an orthogonal error handling mechanism that allows for exception safety while also allowing discrete testability of the return type.</p>
<p><code>result&lt;T,E&gt;</code> types may contain a <code>T</code> value, which signifies that an operation succeeded in producing the result value of type <code>T</code>. If an <code>result</code> does not contain a <code>T</code> value, it will always contain an <code>E</code> error condition instead.</p>
<p>An <code>result&lt;T,E&gt;</code> can always be queried for a possible error case by calling the <code><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#ac1a6da3db72049f2ef3e916e69a93735" title="Returns the contained error, if one exists, or a default-constructed error value. ...">error()</a></code> function, even if it contains a value. In the case that a <code>result&lt;T,E&gt;</code> contains a value object, this will simply return an <code>E</code> object constructed through default aggregate construction, as if through the expression <code>E{}</code>, which is assumed to be a "valid" (no-error) state for an <code>E</code> type. For example:</p>
<ul>
<li><code>std::error_code{}</code> produces a default-construct error-code, which is the "no error" state,</li>
<li>integral (or enum) error codes produce a <code>0</code> value (no error), thanks to zero-initialization,</li>
<li><code>std::exception_ptr{}</code> produces a null-pointer,</li>
<li><code>std::string{}</code> produces an empty string <code>""</code>,</li>
<li>etc.</li>
</ul>
<p>When a <code>result&lt;T,E&gt;</code> contains either a value or error, the storage for that object is guaranteed to be allocated as part of the result object's footprint, i.e. no dynamic memory allocation ever takes place. Thus, a result object models an object, not a pointer, even though the <code><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#a4c42b8a7ea621f5559a296cc131ce645" title="Retrieves a reference to the contained value. ">operator*()</a></code> and <code>operator-&gt;()</code> are defined.</p>
<p>When an object of type <code>result&lt;T,E&gt;</code> is contextually converted to <code>bool</code>, the conversion returns <code>true</code> if the object contains a value and <code>false</code> if it contains an error.</p>
<p><code>result</code> objects do not have a "valueless" state like <code>variant</code>s do. Once a <code>result</code> has been constructed with a value or error, the active underlying type can only be changed through assignment which may is only enabled if construction is guaranteed to be <em>non-throwing</em>. This ensures that a valueless state cannot occur naturally.</p>
<p>Example Use: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> to_string(<span class="keywordtype">int</span> x) -&gt; result&lt;std::string&gt;</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span> {</div><div class="line">    <span class="keywordflow">return</span> std::stoi(x);</div><div class="line">  } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::invalid_argument&amp;) {</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="../../de/d80/result_8hpp.html#ae229fb3e62d7f65fe6b020e16c8c8a30">fail</a>(std::errc::invalid_argument);</div><div class="line">  } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::std::out_of_range&amp;) {</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="../../de/d80/result_8hpp.html#ae229fb3e62d7f65fe6b020e16c8c8a30">fail</a>(std::errc::result_out_of_range);</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>If using C++17 or above, <code>fail</code> can be replaced with <code>failure{...}</code> thanks to CTAD.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the underlying value type </td></tr>
    <tr><td class="paramname">E</td><td>the underlying error type </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../de/d80/result_8hpp_source.html#l00302">302</a> of file <a class="el" href="../../de/d80/result_8hpp_source.html">result.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a294cc61375e0b4d0a0865f5477cff931"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a294cc61375e0b4d0a0865f5477cff931">&#9670;&nbsp;</a></span>result() <span class="overload">[1/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<div class="memtemplate">
template&lt;typename U  = T, typename  = typename std::enable_if&lt;std::is_constructible&lt;U&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default-constructs a result with the underlying value type active. </p>
<p>This constructor is only enabled if <code>T</code> is default-constructible</p>
<h3>Examples</h3>
<p>Basic Usage:</p>
<div class="fragment"><div class="line">assert(cpp::result&lt;std::string,int&gt;{} == std::string{});</div></div><!-- fragment --> 
</div>
</div>
<a id="a6808ac32ce9de8acc667a3f9185ed14a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6808ac32ce9de8acc667a3f9185ed14a">&#9670;&nbsp;</a></span>result() <span class="overload">[2/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a>&lt; T, E &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructs this result. </p>
<p>If <code>other</code> contains a value, initializes the contained value as if direct-initializing (but not direct-list-initializing) an object of type <code>T</code> with the expression *other.</p>
<p>If other contains an error, constructs an object that contains a copy of that error.</p>
<dl class="section note"><dt>Note</dt><dd>This constructor is defined as deleted if <code>std::is_copy_constructible&lt;T&gt;::value</code> or <code>std::is_copy_constructible&lt;E&gt;::value</code> is <code>false</code></dd>
<dd>
This constructor is defined as trivial if both <code>std::is_trivially_copy_constructible&lt;T&gt;::value</code> and <code>std::is_trivially_copy_constructible&lt;E&gt;::value</code> are <code>true</code></dd></dl>
<h3>Examples</h3>
<p>Basic Usage:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> r = cpp::result&lt;int,int&gt;{42};</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> s = r;</div><div class="line"></div><div class="line">assert(r == s);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the result to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a839b1bf77f5a92ff56c119d558bc98c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a839b1bf77f5a92ff56c119d558bc98c7">&#9670;&nbsp;</a></span>result() <span class="overload">[3/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a>&lt; T, E &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructs a result. </p>
<p>If other contains a value, initializes the contained value as if direct-initializing (but not direct-list-initializing) an object of type T with the expression <code>std::move(*other)</code> and does not make other empty: a moved-from result still contains a value, but the value itself is moved from.</p>
<p>If other contains an error, move-constructs this result from that error.</p>
<dl class="section note"><dt>Note</dt><dd>This constructor is defined as deleted if <code>std::is_move_constructible&lt;T&gt;::value</code> or <code>std::is_move_constructible&lt;E&gt;::value</code> is <code>false</code></dd>
<dd>
This constructor is defined as trivial if both <code>std::is_trivially_move_constructible&lt;T&gt;::value</code> and <code>std::is_trivially_move_constructible&lt;E&gt;::value</code> are <code>true</code></dd></dl>
<h3>Examples</h3>
<p>Basic Usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> r = cpp::result&lt;std::string,int&gt;{<span class="stringliteral">&quot;hello world&quot;</span>};</div><div class="line"><span class="keyword">auto</span> s = std::move(r);</div><div class="line"></div><div class="line">assert(s == <span class="stringliteral">&quot;hello world&quot;</span>);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the result to move </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a376f846df51982f34e3ec3f952c39f80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a376f846df51982f34e3ec3f952c39f80">&#9670;&nbsp;</a></span>result() <span class="overload">[4/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<div class="memtemplate">
template&lt;typename T2 , typename E2 , typename std::enable_if&lt; detail::result_is_implicit_copy_convertible&lt; T, E, T2, E2 &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a>&lt; T2, E2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converting copy constructor. </p>
<p>If <code>other</code> contains a value, constructs a result object that contains a value, initialized as if direct-initializing (but not direct-list-initializing) an object of type <code>T</code> with the expression <code>*other</code>.</p>
<p>If <code>other</code> contains an error, constructs a result object that contains an error, initialized as if direct-initializing (but not direct-list-initializing) an object of type <code>E</code>.</p>
<dl class="section note"><dt>Note</dt><dd>This constructor does not participate in overload resolution unless the following conditions are met:<ul>
<li><code>std::is_constructible_v&lt;T, const U&amp;&gt;</code> is <code>true</code></li>
<li>T is not constructible or convertible from any expression of type (possibly const) <code>result&lt;T2,E2&gt;</code></li>
<li>E is not constructible or convertible from any expression of type (possible const) <code>result&lt;T2,E2&gt;</code></li>
</ul>
</dd>
<dd>
This constructor is explicit if and only if <code>std::is_convertible_v&lt;const T2&amp;, T&gt;</code> or <code>std::is_convertible_v&lt;const E2&amp;, E&gt;</code> is <code>false</code></dd></dl>
<h3>Examples</h3>
<p>Basic Usage:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> r = cpp::result&lt;int,int&gt;{42};</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> s = cpp::result&lt;long,long&gt;{r};</div><div class="line"></div><div class="line">assert(r == s);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the other type to convert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a376f846df51982f34e3ec3f952c39f80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a376f846df51982f34e3ec3f952c39f80">&#9670;&nbsp;</a></span>result() <span class="overload">[5/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<div class="memtemplate">
template&lt;typename T2 , typename E2 , typename std::enable_if&lt; detail::result_is_explicit_copy_convertible&lt; T, E, T2, E2 &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a>&lt; T2, E2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converting copy constructor. </p>
<p>If <code>other</code> contains a value, constructs a result object that contains a value, initialized as if direct-initializing (but not direct-list-initializing) an object of type <code>T</code> with the expression <code>*other</code>.</p>
<p>If <code>other</code> contains an error, constructs a result object that contains an error, initialized as if direct-initializing (but not direct-list-initializing) an object of type <code>E</code>.</p>
<dl class="section note"><dt>Note</dt><dd>This constructor does not participate in overload resolution unless the following conditions are met:<ul>
<li><code>std::is_constructible_v&lt;T, const U&amp;&gt;</code> is <code>true</code></li>
<li>T is not constructible or convertible from any expression of type (possibly const) <code>result&lt;T2,E2&gt;</code></li>
<li>E is not constructible or convertible from any expression of type (possible const) <code>result&lt;T2,E2&gt;</code></li>
</ul>
</dd>
<dd>
This constructor is explicit if and only if <code>std::is_convertible_v&lt;const T2&amp;, T&gt;</code> or <code>std::is_convertible_v&lt;const E2&amp;, E&gt;</code> is <code>false</code></dd></dl>
<h3>Examples</h3>
<p>Basic Usage:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> r = cpp::result&lt;int,int&gt;{42};</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> s = cpp::result&lt;long,long&gt;{r};</div><div class="line"></div><div class="line">assert(r == s);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the other type to convert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1077f5f78da88859f109ff2b2756a0e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1077f5f78da88859f109ff2b2756a0e1">&#9670;&nbsp;</a></span>result() <span class="overload">[6/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<div class="memtemplate">
template&lt;typename T2 , typename E2 , typename std::enable_if&lt; detail::result_is_implicit_move_convertible&lt; T, E, T2, E2 &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a>&lt; T2, E2 &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converting move constructor. </p>
<p>If <code>other</code> contains a value, constructs a result object that contains a value, initialized as if direct-initializing (but not direct-list-initializing) an object of type T with the expression <code>std::move(*other)</code>.</p>
<p>If <code>other</code> contains an error, constructs a result object that contains an error, initialized as if direct-initializing (but not direct-list-initializing) an object of type E&amp;&amp;.</p>
<dl class="section note"><dt>Note</dt><dd>This constructor does not participate in overload resolution unless the following conditions are met:<ul>
<li><code>std::is_constructible_v&lt;T, const U&amp;&gt;</code> is <code>true</code></li>
<li>T is not constructible or convertible from any expression of type (possibly const) <code>result&lt;T2,E2&gt;</code></li>
<li>E is not constructible or convertible from any expression of type (possible const) <code>result&lt;T2,E2&gt;</code></li>
</ul>
</dd>
<dd>
This constructor is explicit if and only if <code>std::is_convertible_v&lt;const T2&amp;, T&gt;</code> or <code>std::is_convertible_v&lt;const E2&amp;, E&gt;</code> is <code>false</code></dd></dl>
<h3>Examples</h3>
<p>Basic Usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> r = cpp::result&lt;std::unique_ptr&lt;Derived&gt;,<span class="keywordtype">int</span>&gt;{</div><div class="line">  std::make_unique&lt;Derived&gt;()</div><div class="line">};</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> s = cpp::result&lt;std::unique_ptr&lt;Base&gt;,<span class="keywordtype">long</span>&gt;{</div><div class="line">  std::move(r)</div><div class="line">};</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the other type to convert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1077f5f78da88859f109ff2b2756a0e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1077f5f78da88859f109ff2b2756a0e1">&#9670;&nbsp;</a></span>result() <span class="overload">[7/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<div class="memtemplate">
template&lt;typename T2 , typename E2 , typename std::enable_if&lt; detail::result_is_explicit_move_convertible&lt; T, E, T2, E2 &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a>&lt; T2, E2 &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converting move constructor. </p>
<p>If <code>other</code> contains a value, constructs a result object that contains a value, initialized as if direct-initializing (but not direct-list-initializing) an object of type T with the expression <code>std::move(*other)</code>.</p>
<p>If <code>other</code> contains an error, constructs a result object that contains an error, initialized as if direct-initializing (but not direct-list-initializing) an object of type E&amp;&amp;.</p>
<dl class="section note"><dt>Note</dt><dd>This constructor does not participate in overload resolution unless the following conditions are met:<ul>
<li><code>std::is_constructible_v&lt;T, const U&amp;&gt;</code> is <code>true</code></li>
<li>T is not constructible or convertible from any expression of type (possibly const) <code>result&lt;T2,E2&gt;</code></li>
<li>E is not constructible or convertible from any expression of type (possible const) <code>result&lt;T2,E2&gt;</code></li>
</ul>
</dd>
<dd>
This constructor is explicit if and only if <code>std::is_convertible_v&lt;const T2&amp;, T&gt;</code> or <code>std::is_convertible_v&lt;const E2&amp;, E&gt;</code> is <code>false</code></dd></dl>
<h3>Examples</h3>
<p>Basic Usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> r = cpp::result&lt;std::unique_ptr&lt;Derived&gt;,<span class="keywordtype">int</span>&gt;{</div><div class="line">  std::make_unique&lt;Derived&gt;()</div><div class="line">};</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> s = cpp::result&lt;std::unique_ptr&lt;Base&gt;,<span class="keywordtype">long</span>&gt;{</div><div class="line">  std::move(r)</div><div class="line">};</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the other type to convert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e9c452ba7ab0130f0f4776aec66f49a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e9c452ba7ab0130f0f4776aec66f49a">&#9670;&nbsp;</a></span>result() <span class="overload">[8/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<div class="memtemplate">
template&lt;typename... Args, typename  = typename std::enable_if&lt;std::is_constructible&lt;T,Args...&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d99/structcpp_1_1bitwizeshift_1_1in__place__t.html">in_place_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a result object that contains a value. </p>
<p>The value is initialized as if direct-initializing (but not direct-list-initializing) an object of type <code>T</code> from the arguments <code>std::forward&lt;Args&gt;(args)...</code></p>
<h3>Examples</h3>
<p>Basic Usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> r = cpp::result&lt;std::string,int&gt;{</div><div class="line">  cpp::in_place, <span class="stringliteral">&quot;Hello world&quot;</span></div><div class="line">};</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>the arguments to pass to T's constructor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae126a3af750a64eec9ebe7b2325afe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae126a3af750a64eec9ebe7b2325afe2">&#9670;&nbsp;</a></span>result() <span class="overload">[9/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<div class="memtemplate">
template&lt;typename U , typename... Args, typename  = typename std::enable_if&lt;std::is_constructible&lt;T, std::initializer_list&lt;U&gt;&amp;, Args...&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d99/structcpp_1_1bitwizeshift_1_1in__place__t.html">in_place_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; U &gt;&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a result object that contains a value. </p>
<p>The value is initialized as if direct-initializing (but not direct-list-initializing) an object of type <code>T</code> from the arguments <code>std::forward&lt;std::initializer_list&lt;U&gt;&gt;(ilist)</code>, <code>std::forward&lt;Args&gt;(args)...</code></p>
<h3>Examples</h3>
<p>Basic Usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> r = cpp::result&lt;std::string,int&gt;{</div><div class="line">  cpp::in_place, {<span class="charliteral">&#39;H&#39;</span>,<span class="charliteral">&#39;e&#39;</span>,<span class="charliteral">&#39;l&#39;</span>,<span class="charliteral">&#39;l&#39;</span>,<span class="charliteral">&#39;o&#39;</span>}</div><div class="line">};</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ilist</td><td>An initializer list of entries to forward </td></tr>
    <tr><td class="paramname">args</td><td>the arguments to pass to T's constructor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a691fbdb19ae0c4fb858aa8425c51d5de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a691fbdb19ae0c4fb858aa8425c51d5de">&#9670;&nbsp;</a></span>result() <span class="overload">[10/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<div class="memtemplate">
template&lt;typename... Args, typename  = typename std::enable_if&lt;std::is_constructible&lt;E,Args...&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/d00/structcpp_1_1bitwizeshift_1_1in__place__error__t.html">in_place_error_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a result object that contains an error. </p>
<p>the value is initialized as if direct-initializing (but not direct-list-initializing) an object of type <code>E</code> from the arguments <code>std::forward&lt;Args&gt;(args)...</code></p>
<h3>Examples</h3>
<p>Basic Usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> r = cpp::result&lt;int,std::string&gt;{</div><div class="line">  cpp::in_place_error, <span class="stringliteral">&quot;Hello world&quot;</span></div><div class="line">};</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>the arguments to pass to E's constructor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a59c7df8b675c1f7177b22a74da477f62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59c7df8b675c1f7177b22a74da477f62">&#9670;&nbsp;</a></span>result() <span class="overload">[11/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<div class="memtemplate">
template&lt;typename U , typename... Args, typename  = typename std::enable_if&lt;std::is_constructible&lt;E, std::initializer_list&lt;U&gt;&amp;, Args...&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/d00/structcpp_1_1bitwizeshift_1_1in__place__error__t.html">in_place_error_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; U &gt;&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a result object that contains an error. </p>
<p>The value is initialized as if direct-initializing (but not direct-list-initializing) an object of type <code>E</code> from the arguments <code>std::forward&lt;std::initializer_list&lt;U&gt;&gt;(ilist)</code>, <code>std::forward&lt;Args&gt;(args)...</code></p>
<h3>Examples</h3>
<p>Basic Usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> r = cpp::result&lt;int,std::string&gt;{</div><div class="line">  cpp::in_place_error, {<span class="charliteral">&#39;H&#39;</span>,<span class="charliteral">&#39;e&#39;</span>,<span class="charliteral">&#39;l&#39;</span>,<span class="charliteral">&#39;l&#39;</span>,<span class="charliteral">&#39;o&#39;</span>}</div><div class="line">};</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ilist</td><td>An initializer list of entries to forward </td></tr>
    <tr><td class="paramname">args</td><td>the arguments to pass to Es constructor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeb12608ba169d73dcac5204aefe5adb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb12608ba169d73dcac5204aefe5adb3">&#9670;&nbsp;</a></span>result() <span class="overload">[12/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<div class="memtemplate">
template&lt;typename E2 , typename  = typename std::enable_if&lt;std::is_constructible&lt;E,const E2&amp;&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/dd0/classcpp_1_1bitwizeshift_1_1failure.html">failure</a>&lt; E2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the underlying error of this result. </p>
<dl class="section note"><dt>Note</dt><dd>This constructor only participates in overload resolution if <code>E</code> is constructible from <code>e</code> </dd></dl>
<h3>Examples</h3>
<p>Basic Usage:</p>
<div class="fragment"><div class="line">cpp::result&lt;int,int&gt; r = cpp::fail(42);</div><div class="line"></div><div class="line"><span class="keyword">auto</span> get_error_result() -&gt; cpp::result&lt;int,std::string&gt; {</div><div class="line">  <span class="keywordflow">return</span> cpp::fail(<span class="stringliteral">&quot;hello world!&quot;</span>);</div><div class="line">}</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the failure error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3361d2b8a668de4335fada30b1c3d9b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3361d2b8a668de4335fada30b1c3d9b3">&#9670;&nbsp;</a></span>result() <span class="overload">[13/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<div class="memtemplate">
template&lt;typename E2 , typename  = typename std::enable_if&lt;std::is_constructible&lt;E,E2&amp;&amp;&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dd0/classcpp_1_1bitwizeshift_1_1failure.html">failure</a>&lt; E2 &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the underlying error of this result. </p>
<dl class="section note"><dt>Note</dt><dd>This constructor only participates in overload resolution if <code>E</code> is constructible from <code>e</code> </dd></dl>
<h3>Examples</h3>
<p>Basic Usage:</p>
<div class="fragment"><div class="line">cpp::result&lt;int,int&gt; r = cpp::fail(42);</div><div class="line"></div><div class="line"><span class="keyword">auto</span> get_error_result() -&gt; cpp::result&lt;int,std::string&gt; {</div><div class="line">  <span class="keywordflow">return</span> cpp::fail(<span class="stringliteral">&quot;hello world!&quot;</span>);</div><div class="line">}</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the failure error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a32a98dddc040fe525855b443115167e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32a98dddc040fe525855b443115167e8">&#9670;&nbsp;</a></span>result() <span class="overload">[14/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<div class="memtemplate">
template&lt;typename U , typename std::enable_if&lt; detail::result_is_explicit_value_convertible&lt; T, U &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a> </td>
          <td>(</td>
          <td class="paramtype">U &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a result object that contains a value. </p>
<p>The value is initialized as if direct-initializing (but not direct-list-initializing) an object of type T with the expression value.</p>
<dl class="section note"><dt>Note</dt><dd>This constructor is constexpr if the constructor of T selected by direct-initialization is constexpr</dd>
<dd>
This constructor does not participate in overload resolution unless <code>std::is_constructible_v&lt;T, U&amp;&amp;&gt;</code> is true and <code>decay_t&lt;U&gt;</code> is neither <code><a class="el" href="../../d0/d99/structcpp_1_1bitwizeshift_1_1in__place__t.html" title="A structure for representing in-place construction. ">in_place_t</a></code>, <code><a class="el" href="../../d1/d00/structcpp_1_1bitwizeshift_1_1in__place__error__t.html" title="A structure for representing in-place construction of an error type. ">in_place_error_t</a></code>, nor a <code>result</code> type.</dd>
<dd>
This constructor is explicit if and only if <code>std::is_convertible_v&lt;U&amp;&amp;, T&gt;</code> is <code>false</code></dd></dl>
<h3>Examples</h3>
<p>Basic Usage:</p>
<div class="fragment"><div class="line">cpp::result&lt;int,int&gt; r = 42;</div><div class="line"></div><div class="line"><span class="keyword">auto</span> get_value() -&gt; cpp::result&lt;std::string,int&gt; {</div><div class="line">  <span class="keywordflow">return</span> <span class="stringliteral">&quot;hello world!&quot;</span>; <span class="comment">// implicit conversion</span></div><div class="line">}</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a32a98dddc040fe525855b443115167e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32a98dddc040fe525855b443115167e8">&#9670;&nbsp;</a></span>result() <span class="overload">[15/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<div class="memtemplate">
template&lt;typename U , typename std::enable_if&lt; detail::result_is_implicit_value_convertible&lt; T, U &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::<a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a> </td>
          <td>(</td>
          <td class="paramtype">U &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a result object that contains a value. </p>
<p>The value is initialized as if direct-initializing (but not direct-list-initializing) an object of type T with the expression value.</p>
<dl class="section note"><dt>Note</dt><dd>This constructor is constexpr if the constructor of T selected by direct-initialization is constexpr</dd>
<dd>
This constructor does not participate in overload resolution unless <code>std::is_constructible_v&lt;T, U&amp;&amp;&gt;</code> is true and <code>decay_t&lt;U&gt;</code> is neither <code><a class="el" href="../../d0/d99/structcpp_1_1bitwizeshift_1_1in__place__t.html" title="A structure for representing in-place construction. ">in_place_t</a></code>, <code><a class="el" href="../../d1/d00/structcpp_1_1bitwizeshift_1_1in__place__error__t.html" title="A structure for representing in-place construction of an error type. ">in_place_error_t</a></code>, nor a <code>result</code> type.</dd>
<dd>
This constructor is explicit if and only if <code>std::is_convertible_v&lt;U&amp;&amp;, T&gt;</code> is <code>false</code></dd></dl>
<h3>Examples</h3>
<p>Basic Usage:</p>
<div class="fragment"><div class="line">cpp::result&lt;int,int&gt; r = 42;</div><div class="line"></div><div class="line"><span class="keyword">auto</span> get_value() -&gt; cpp::result&lt;std::string,int&gt; {</div><div class="line">  <span class="keywordflow">return</span> <span class="stringliteral">&quot;hello world!&quot;</span>; <span class="comment">// implicit conversion</span></div><div class="line">}</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa741ce67edc24d27a5f58cc16e1e214d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa741ce67edc24d27a5f58cc16e1e214d">&#9670;&nbsp;</a></span>and_then()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RESULT_WARN_UNUSED constexpr auto <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::and_then </td>
          <td>(</td>
          <td class="paramtype">U &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const -&gt;  <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a>&lt; typename std::decay&lt; U &gt;::type, E &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a result containing <code>value</code> if this result contains a value, otherwise returns a result containing the current error. </p>
<h3>Examples</h3>
<p>Basic Usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> r = cpp::result&lt;int,int&gt;{42};</div><div class="line">assert(r.and_then(100) == 100);</div><div class="line"></div><div class="line"><span class="keyword">auto</span> r = cpp::result&lt;int,int&gt;{cpp::fail(42)};</div><div class="line">assert(r.and_then(100) == cpp::fail(42));</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value to return as a result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result of <code>value</code> if this contains a value </dd></dl>

</div>
</div>
<a id="ac1a6da3db72049f2ef3e916e69a93735"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1a6da3db72049f2ef3e916e69a93735">&#9670;&nbsp;</a></span>error() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RESULT_WARN_UNUSED constexpr auto <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::error </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;&amp; -&gt;  E</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the contained error, if one exists, or a default-constructed error value. </p>
<p>The <code><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#ac1a6da3db72049f2ef3e916e69a93735" title="Returns the contained error, if one exists, or a default-constructed error value. ...">error()</a></code> function will not throw any exceptions if <code>E</code> does not throw any exceptions for the copy or move construction.</p>
<p>This is to limit the possible scope for exceptions, and to allow the error type to be treated as a "status"-like type, where the default-constructed case is considered the "good" state.</p>
<p>If this function is invoked on an rvalue of a result, the error is returned via move-construction</p>
<h3>Requires</h3>
<ul>
<li><code>std::is_default_constructible&lt;E&gt;::value</code> is <code>true</code></li>
<li><code>std::is_copy_constructible&lt;E&gt;::value</code> or <code>std::is_move_constructible&lt;E&gt;::value</code> is <code>true</code></li>
<li><code>E{}</code> represents the "good" (non-error) state</li>
</ul>
<h3>Examples</h3>
<p>Basic Usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> r = cpp::result&lt;int,std::error_code&gt;{ 42 };</div><div class="line">assert(r.error() == std::error_code{});</div><div class="line"></div><div class="line"><span class="keyword">auto</span> r = cpp::result&lt;int,std::error_code&gt;{</div><div class="line">  cpp::fail(std::io_errc::stream)</div><div class="line">};</div><div class="line"></div><div class="line">assert(r.error() == std::io_errc::stream);</div></div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>the error or a default-constructed error value </dd></dl>

</div>
</div>
<a id="a35676e4f60e0aab8f705caec8fe86620"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35676e4f60e0aab8f705caec8fe86620">&#9670;&nbsp;</a></span>error() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RESULT_WARN_UNUSED RESULT_CPP14_CONSTEXPR auto <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::error </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;&amp; -&gt;  E</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the contained error, if one exists, or a default-constructed error value. </p>
<p>The <code><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#ac1a6da3db72049f2ef3e916e69a93735" title="Returns the contained error, if one exists, or a default-constructed error value. ...">error()</a></code> function will not throw any exceptions if <code>E</code> does not throw any exceptions for the copy or move construction.</p>
<p>This is to limit the possible scope for exceptions, and to allow the error type to be treated as a "status"-like type, where the default-constructed case is considered the "good" state.</p>
<p>If this function is invoked on an rvalue of a result, the error is returned via move-construction</p>
<h3>Requires</h3>
<ul>
<li><code>std::is_default_constructible&lt;E&gt;::value</code> is <code>true</code></li>
<li><code>std::is_copy_constructible&lt;E&gt;::value</code> or <code>std::is_move_constructible&lt;E&gt;::value</code> is <code>true</code></li>
<li><code>E{}</code> represents the "good" (non-error) state</li>
</ul>
<h3>Examples</h3>
<p>Basic Usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> r = cpp::result&lt;int,std::error_code&gt;{ 42 };</div><div class="line">assert(r.error() == std::error_code{});</div><div class="line"></div><div class="line"><span class="keyword">auto</span> r = cpp::result&lt;int,std::error_code&gt;{</div><div class="line">  cpp::fail(std::io_errc::stream)</div><div class="line">};</div><div class="line"></div><div class="line">assert(r.error() == std::io_errc::stream);</div></div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>the error or a default-constructed error value </dd></dl>

</div>
</div>
<a id="a0b1f8f312619e37594054f94a283a48f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b1f8f312619e37594054f94a283a48f">&#9670;&nbsp;</a></span>error_or() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RESULT_WARN_UNUSED constexpr auto <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::error_or </td>
          <td>(</td>
          <td class="paramtype">U &amp;&amp;&#160;</td>
          <td class="paramname"><em>default_error</em></td><td>)</td>
          <td> const &amp; -&gt;  <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#acf649f8e04fe1e24ffa827d2dbd1bbc1">error_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the contained error if <code>*this</code> has an error, otherwise returns <code>default_error</code>. </p>
<h3>Examples</h3>
<p>Basic Usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> r = cpp::result&lt;int,int&gt;{42};</div><div class="line">assert(r.error_or(0) == cpp::fail(0));</div><div class="line"></div><div class="line"><span class="keyword">auto</span> r = cpp::result&lt;int,int&gt;{cpp::fail(42)};</div><div class="line">assert(r.error_or(0) == cpp::fail(42));</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">default_error</td><td>the error to use in case <code>*this</code> is empty </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the contained value or <code>default_error</code> </dd></dl>

</div>
</div>
<a id="ab56c3d217a7fc14c8e33425192cd9aa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab56c3d217a7fc14c8e33425192cd9aa0">&#9670;&nbsp;</a></span>error_or() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RESULT_WARN_UNUSED RESULT_CPP14_CONSTEXPR auto <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::error_or </td>
          <td>(</td>
          <td class="paramtype">U &amp;&amp;&#160;</td>
          <td class="paramname"><em>default_error</em></td><td>)</td>
          <td> &amp;&amp; -&gt;  <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#acf649f8e04fe1e24ffa827d2dbd1bbc1">error_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the contained error if <code>*this</code> has an error, otherwise returns <code>default_error</code>. </p>
<h3>Examples</h3>
<p>Basic Usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> r = cpp::result&lt;int,int&gt;{42};</div><div class="line">assert(r.error_or(0) == cpp::fail(0));</div><div class="line"></div><div class="line"><span class="keyword">auto</span> r = cpp::result&lt;int,int&gt;{cpp::fail(42)};</div><div class="line">assert(r.error_or(0) == cpp::fail(42));</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">default_error</td><td>the error to use in case <code>*this</code> is empty </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the contained value or <code>default_error</code> </dd></dl>

</div>
</div>
<a id="aff9d84e6e09ccfab440166b4ef1a7766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff9d84e6e09ccfab440166b4ef1a7766">&#9670;&nbsp;</a></span>expect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<div class="memtemplate">
template&lt;typename String , typename  = typename std::enable_if&lt;(                std::is_convertible&lt;String,const std::string&amp;&gt;::value &amp;&amp;                std::is_copy_constructible&lt;E&gt;::value              )&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RESULT_CPP14_CONSTEXPR auto <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::expect </td>
          <td>(</td>
          <td class="paramtype">String &amp;&amp;&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td> const &amp; -&gt;  void</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>} </p>
<p>Asserts an expectation that this result contains an error, throwing a <a class="el" href="../../de/dac/classcpp_1_1bitwizeshift_1_1bad__result__access.html" title="An exception thrown when result::value is accessed without a contained value. ">bad_result_access</a> on failure</p>
<p>If this function is invoked from an rvalue of <code>result</code>, then this will consume the underlying error first, if there is one.</p>
<dl class="section note"><dt>Note</dt><dd>This function exists as a means to allow for results to be marked <code>used</code> without requiring directly inspecting the underlying value. This is, in effect, equivalent to <code>assert(res.has_value())</code>, however it uses exceptions to ensure the stack can be unwound, and exceptions invoked.</dd></dl>
<h3>Examples</h3>
<p>Basic Usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> start_service() -&gt; cpp::result&lt;void,int&gt;;</div><div class="line"></div><div class="line">start_service().expect(<span class="stringliteral">&quot;Service failed to start!&quot;</span>);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>the message to provide to this expectation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abfc85857bc1cbd4098a3ec7587176abc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfc85857bc1cbd4098a3ec7587176abc">&#9670;&nbsp;</a></span>expect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<div class="memtemplate">
template&lt;typename String , typename  = typename std::enable_if&lt;(                std::is_convertible&lt;String,const std::string&amp;&gt;::value &amp;&amp;                std::is_move_constructible&lt;E&gt;::value              )&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RESULT_CPP14_CONSTEXPR auto <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::expect </td>
          <td>(</td>
          <td class="paramtype">String &amp;&amp;&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td> &amp;&amp; -&gt;  void</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the contained error, if one exists, or a default-constructed error value. </p>
<p>The <code><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html#ac1a6da3db72049f2ef3e916e69a93735" title="Returns the contained error, if one exists, or a default-constructed error value. ...">error()</a></code> function will not throw any exceptions if <code>E</code> does not throw any exceptions for the copy or move construction.</p>
<p>This is to limit the possible scope for exceptions, and to allow the error type to be treated as a "status"-like type, where the default-constructed case is considered the "good" state.</p>
<p>If this function is invoked on an rvalue of a result, the error is returned via move-construction</p>
<h3>Requires</h3>
<ul>
<li><code>std::is_default_constructible&lt;E&gt;::value</code> is <code>true</code></li>
<li><code>std::is_copy_constructible&lt;E&gt;::value</code> or <code>std::is_move_constructible&lt;E&gt;::value</code> is <code>true</code></li>
<li><code>E{}</code> represents the "good" (non-error) state</li>
</ul>
<h3>Examples</h3>
<p>Basic Usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> r = cpp::result&lt;int,std::error_code&gt;{ 42 };</div><div class="line">assert(r.error() == std::error_code{});</div><div class="line"></div><div class="line"><span class="keyword">auto</span> r = cpp::result&lt;int,std::error_code&gt;{</div><div class="line">  cpp::fail(std::io_errc::stream)</div><div class="line">};</div><div class="line"></div><div class="line">assert(r.error() == std::io_errc::stream);</div></div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>the error or a default-constructed error value </dd></dl>

</div>
</div>
<a id="a516eda185e20c05b1290def23b80155c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a516eda185e20c05b1290def23b80155c">&#9670;&nbsp;</a></span>flat_map() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<div class="memtemplate">
template&lt;typename Fn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RESULT_WARN_UNUSED constexpr auto <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::flat_map </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>fn</em></td><td>)</td>
          <td> const &amp; -&gt;  detail::invoke_result_t&lt; Fn, const T &amp;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invokes the function <code>fn</code> with the value of this result as the argument. </p>
<p>If this result contains an error, a result of the error is returned</p>
<p>The function being called must return a <code>result</code> type or the program is ill-formed</p>
<p>If this is called on an rvalue of <code>result</code> which contains an error, the returned <code>result</code> is constructed from an rvalue of that error.</p>
<h3>Examples</h3>
<p>Basic Usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> to_string(<span class="keywordtype">int</span>) -&gt; cpp::result&lt;std::string,int&gt;;</div><div class="line"><span class="keyword">auto</span> r = cpp::result&lt;int,int&gt;{42};</div><div class="line">assert(r.flat_map(to_string) == <span class="stringliteral">&quot;42&quot;</span>);</div><div class="line"></div><div class="line"><span class="keyword">auto</span> r = cpp::result&lt;int,int&gt;{cpp::fail(42)};</div><div class="line">assert(r.flat_map(to_string) == cpp::fail(42));</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn</td><td>the function to invoke with this </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the function being called </dd></dl>

</div>
</div>
<a id="a136350853506e48fe93e4e1f44c389fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a136350853506e48fe93e4e1f44c389fe">&#9670;&nbsp;</a></span>flat_map() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<div class="memtemplate">
template&lt;typename Fn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RESULT_WARN_UNUSED RESULT_CPP14_CONSTEXPR auto <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::flat_map </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>fn</em></td><td>)</td>
          <td> &amp;&amp; -&gt;  detail::invoke_result_t&lt; Fn, T &amp;&amp;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invokes the function <code>fn</code> with the value of this result as the argument. </p>
<p>If this result contains an error, a result of the error is returned</p>
<p>The function being called must return a <code>result</code> type or the program is ill-formed</p>
<p>If this is called on an rvalue of <code>result</code> which contains an error, the returned <code>result</code> is constructed from an rvalue of that error.</p>
<h3>Examples</h3>
<p>Basic Usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> to_string(<span class="keywordtype">int</span>) -&gt; cpp::result&lt;std::string,int&gt;;</div><div class="line"><span class="keyword">auto</span> r = cpp::result&lt;int,int&gt;{42};</div><div class="line">assert(r.flat_map(to_string) == <span class="stringliteral">&quot;42&quot;</span>);</div><div class="line"></div><div class="line"><span class="keyword">auto</span> r = cpp::result&lt;int,int&gt;{cpp::fail(42)};</div><div class="line">assert(r.flat_map(to_string) == cpp::fail(42));</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn</td><td>the function to invoke with this </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the function being called </dd></dl>

</div>
</div>
<a id="a820ce0afdea9a7bfa1be9d6fdb14d308"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a820ce0afdea9a7bfa1be9d6fdb14d308">&#9670;&nbsp;</a></span>flat_map_error() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<div class="memtemplate">
template&lt;typename Fn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RESULT_WARN_UNUSED constexpr auto <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::flat_map_error </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>fn</em></td><td>)</td>
          <td> const &amp; -&gt;  detail::invoke_result_t&lt; Fn, const E &amp;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invokes the function <code>fn</code> with the error of this result as the argument. </p>
<p>If this result contains a value, a result of the value is returned</p>
<p>The function being called must return a <code>result</code> type or the program is ill-formed</p>
<p>If this is called on an rvalue of <code>result</code> which contains an error, the returned <code>result</code> is constructed from an rvalue of that error.</p>
<h3>Examples</h3>
<p>Basic Usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> to_string(<span class="keywordtype">int</span>) -&gt; cpp::result&lt;int,std::string&gt;;</div><div class="line"><span class="keyword">auto</span> r = cpp::result&lt;int,int&gt;{42};</div><div class="line">assert(r.flat_map(to_string) == 42);</div><div class="line"></div><div class="line"><span class="keyword">auto</span> r = cpp::result&lt;int,int&gt;{cpp::fail(42)};</div><div class="line">assert(r.flat_map(to_string) == cpp::fail(<span class="stringliteral">&quot;42&quot;</span>));</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn</td><td>the function to invoke with this </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the function being called </dd></dl>

</div>
</div>
<a id="a90d7bbcddb8d25a04905852eb6e3bade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90d7bbcddb8d25a04905852eb6e3bade">&#9670;&nbsp;</a></span>flat_map_error() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<div class="memtemplate">
template&lt;typename Fn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RESULT_WARN_UNUSED RESULT_CPP14_CONSTEXPR auto <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::flat_map_error </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>fn</em></td><td>)</td>
          <td> &amp;&amp; -&gt;  detail::invoke_result_t&lt; Fn, E &amp;&amp;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invokes the function <code>fn</code> with the error of this result as the argument. </p>
<p>If this result contains a value, a result of the value is returned</p>
<p>The function being called must return a <code>result</code> type or the program is ill-formed</p>
<p>If this is called on an rvalue of <code>result</code> which contains an error, the returned <code>result</code> is constructed from an rvalue of that error.</p>
<h3>Examples</h3>
<p>Basic Usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> to_string(<span class="keywordtype">int</span>) -&gt; cpp::result&lt;int,std::string&gt;;</div><div class="line"><span class="keyword">auto</span> r = cpp::result&lt;int,int&gt;{42};</div><div class="line">assert(r.flat_map(to_string) == 42);</div><div class="line"></div><div class="line"><span class="keyword">auto</span> r = cpp::result&lt;int,int&gt;{cpp::fail(42)};</div><div class="line">assert(r.flat_map(to_string) == cpp::fail(<span class="stringliteral">&quot;42&quot;</span>));</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn</td><td>the function to invoke with this </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the function being called </dd></dl>

</div>
</div>
<a id="a13104666eb498cf58c91fcd22ac6ad89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13104666eb498cf58c91fcd22ac6ad89">&#9670;&nbsp;</a></span>has_error()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RESULT_WARN_UNUSED constexpr auto <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::has_error </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt;  bool</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if <code>*this</code> contains an error. </p>
<h3>Examples</h3>
<p>Basic Usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> get_result() -&gt; cpp::result&lt;int, int&gt;;</div><div class="line"></div><div class="line"><span class="keyword">auto</span> r = get_result();</div><div class="line"><span class="keywordflow">if</span> (r.has_error()) { ... }</div><div class="line"></div><div class="line">assert(!cpp::result&lt;int,int&gt;{42}.has_error());</div><div class="line"></div><div class="line">assert(cpp::result&lt;int,int&gt;{cpp::fail(42)}.has_error());</div></div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>*this</code> contains an error, <code>false</code> if <code>*this</code> contains a value </dd></dl>

</div>
</div>
<a id="a4e6e79bb2df85cf71375a366cd03c17a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e6e79bb2df85cf71375a366cd03c17a">&#9670;&nbsp;</a></span>has_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RESULT_WARN_UNUSED constexpr auto <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::has_value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt;  bool</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if <code>*this</code> contains a value. </p>
<h3>Examples</h3>
<p>Basic Usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> get_result() -&gt; cpp::result&lt;int, int&gt;;</div><div class="line"><span class="keyword">auto</span> r = get_result();</div><div class="line"><span class="keywordflow">if</span> (r.has_value()) { ... }</div><div class="line"></div><div class="line">assert(cpp::result&lt;int,int&gt;{42}.has_value());</div><div class="line"></div><div class="line">assert(!cpp::result&lt;int,int&gt;{cpp::fail(42)}.has_value());</div></div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>*this</code> contains a value, <code>false</code> if <code>*this</code> contains an error </dd></dl>

</div>
</div>
<a id="a4021b0883f546564e3474f7ead6d682b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4021b0883f546564e3474f7ead6d682b">&#9670;&nbsp;</a></span>map() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<div class="memtemplate">
template&lt;typename Fn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RESULT_WARN_UNUSED constexpr auto <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::map </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>fn</em></td><td>)</td>
          <td> const &amp; -&gt;  <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a>&lt; detail::invoke_result_t&lt; Fn, const T &amp;&gt;, E &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invokes the function <code>fn</code> with the value of this result as the argument. </p>
<p>If this result is an error, the result of this function is that error. Otherwise this function wraps the result and returns it as an result.</p>
<p>If this is called on an rvalue of <code>result</code> which contains an error, the returned <code>result</code> is constructed from an rvalue of that error.</p>
<h3>Examples</h3>
<p>Basic Usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> to_string(<span class="keywordtype">int</span>) -&gt; std::string;</div><div class="line"><span class="keyword">auto</span> r = cpp::result&lt;int,int&gt;{42};</div><div class="line">assert(r.map(to_string) == <span class="stringliteral">&quot;42&quot;</span>);</div><div class="line"></div><div class="line"><span class="keyword">auto</span> r = cpp::result&lt;int,int&gt;{cpp::fail(42)};</div><div class="line">assert(r.map(to_string) == cpp::fail(42));</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn</td><td>the function to invoke with this </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result result of the function invoked </dd></dl>

</div>
</div>
<a id="ab92526f21d8f2e9b991bd212d3b63965"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab92526f21d8f2e9b991bd212d3b63965">&#9670;&nbsp;</a></span>map() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<div class="memtemplate">
template&lt;typename Fn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RESULT_WARN_UNUSED RESULT_CPP14_CONSTEXPR auto <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::map </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>fn</em></td><td>)</td>
          <td> &amp;&amp; -&gt;  <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a>&lt; detail::invoke_result_t&lt; Fn, T &amp;&amp;&gt;, E &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invokes the function <code>fn</code> with the value of this result as the argument. </p>
<p>If this result is an error, the result of this function is that error. Otherwise this function wraps the result and returns it as an result.</p>
<p>If this is called on an rvalue of <code>result</code> which contains an error, the returned <code>result</code> is constructed from an rvalue of that error.</p>
<h3>Examples</h3>
<p>Basic Usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> to_string(<span class="keywordtype">int</span>) -&gt; std::string;</div><div class="line"><span class="keyword">auto</span> r = cpp::result&lt;int,int&gt;{42};</div><div class="line">assert(r.map(to_string) == <span class="stringliteral">&quot;42&quot;</span>);</div><div class="line"></div><div class="line"><span class="keyword">auto</span> r = cpp::result&lt;int,int&gt;{cpp::fail(42)};</div><div class="line">assert(r.map(to_string) == cpp::fail(42));</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn</td><td>the function to invoke with this </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result result of the function invoked </dd></dl>

</div>
</div>
<a id="ab91bca764d3ef5fb26a83a2da683dc4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab91bca764d3ef5fb26a83a2da683dc4e">&#9670;&nbsp;</a></span>map_error() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<div class="memtemplate">
template&lt;typename Fn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RESULT_WARN_UNUSED constexpr auto <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::map_error </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>fn</em></td><td>)</td>
          <td> const &amp; -&gt;  <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a>&lt; T, detail::invoke_result_t&lt; Fn, const E &amp;&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invokes the function <code>fn</code> with the error of this result as the argument. </p>
<p>If this result contains a value, the result of this function is that value. Otherwise the function is called with that error and returns the result as a result.</p>
<p>If this is called on an rvalue of <code>result</code> which contains a value, the returned <code>result</code> is constructed from an rvalue of that value.</p>
<h3>Examples</h3>
<p>Basic Usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> to_string(<span class="keywordtype">int</span>) -&gt; std::string;</div><div class="line"><span class="keyword">auto</span> r = cpp::result&lt;int,int&gt;{42};</div><div class="line">assert(r.map_error(to_string) == 42);</div><div class="line"></div><div class="line"><span class="keyword">auto</span> r = cpp::result&lt;int,int&gt;{cpp::fail(42)};</div><div class="line">assert(r.map_error(to_string) == cpp::fail(<span class="stringliteral">&quot;42&quot;</span>));</div><div class="line"></div><div class="line"><span class="keyword">auto</span> r = cpp::result&lt;std::string,int&gt;{};</div><div class="line"><span class="keyword">auto</span> s = r.map(std::string::size); <span class="comment">// &#39;s&#39; contains &#39;result&lt;size_t,int&gt;&#39;</span></div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn</td><td>the function to invoke with this </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result result of the function invoked </dd></dl>

</div>
</div>
<a id="a70f80dcc9dcd3527a7c2aa72e09885b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70f80dcc9dcd3527a7c2aa72e09885b9">&#9670;&nbsp;</a></span>map_error() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<div class="memtemplate">
template&lt;typename Fn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RESULT_WARN_UNUSED RESULT_CPP14_CONSTEXPR auto <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::map_error </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>fn</em></td><td>)</td>
          <td> &amp;&amp; -&gt;  <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a>&lt; T, detail::invoke_result_t&lt; Fn, E &amp;&amp;&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invokes the function <code>fn</code> with the error of this result as the argument. </p>
<p>If this result contains a value, the result of this function is that value. Otherwise the function is called with that error and returns the result as a result.</p>
<p>If this is called on an rvalue of <code>result</code> which contains a value, the returned <code>result</code> is constructed from an rvalue of that value.</p>
<h3>Examples</h3>
<p>Basic Usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> to_string(<span class="keywordtype">int</span>) -&gt; std::string;</div><div class="line"><span class="keyword">auto</span> r = cpp::result&lt;int,int&gt;{42};</div><div class="line">assert(r.map_error(to_string) == 42);</div><div class="line"></div><div class="line"><span class="keyword">auto</span> r = cpp::result&lt;int,int&gt;{cpp::fail(42)};</div><div class="line">assert(r.map_error(to_string) == cpp::fail(<span class="stringliteral">&quot;42&quot;</span>));</div><div class="line"></div><div class="line"><span class="keyword">auto</span> r = cpp::result&lt;std::string,int&gt;{};</div><div class="line"><span class="keyword">auto</span> s = r.map(std::string::size); <span class="comment">// &#39;s&#39; contains &#39;result&lt;size_t,int&gt;&#39;</span></div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn</td><td>the function to invoke with this </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result result of the function invoked </dd></dl>

</div>
</div>
<a id="afc91910d9e3ad9dcfccd26e8500a02db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc91910d9e3ad9dcfccd26e8500a02db">&#9670;&nbsp;</a></span>operator bool()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RESULT_WARN_UNUSED constexpr <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::operator bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Contextually convertible to <code>true</code> if <code>*this</code> contains a value. </p>
<p>This function exists to allow for simple, terse checks for containing a value.</p>
<h3>Examples</h3>
<p>Basic Usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> get_result() -&gt; cpp::result&lt;int, int&gt;;</div><div class="line"><span class="keyword">auto</span> r = get_result();</div><div class="line"><span class="keywordflow">if</span> (r) { ... }</div><div class="line"></div><div class="line">assert(static_cast&lt;bool&gt;(cpp::result&lt;int,int&gt;{42}));</div><div class="line"></div><div class="line">assert(!static_cast&lt;bool&gt;(cpp::result&lt;int,int&gt;{cpp::fail(42)}));</div></div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>*this</code> contains a value, <code>false</code> if <code>*this</code> does not contain a value </dd></dl>

</div>
</div>
<a id="a4c42b8a7ea621f5559a296cc131ce645"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c42b8a7ea621f5559a296cc131ce645">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RESULT_WARN_UNUSED RESULT_CPP14_CONSTEXPR auto <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp; -&gt;  typename std::add_lvalue_reference&lt; T &gt;::type</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves a reference to the contained value. </p>
<p>This operator exists to give <code>result</code> an <code>optional</code>-like API for cases where it's known that the <code>result</code> already contains a value.</p>
<p>Care must be taken to ensure that this is only used in safe contexts where a <code>T</code> value is active.</p>
<dl class="section note"><dt>Note</dt><dd>The behaviour is undefined if <code>*this</code> does not contain a value</dd></dl>
<h3>Examples</h3>
<p>Basic Usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> r = cpp::result&lt;Widget,int&gt;{</div><div class="line">  make_widget()</div><div class="line">};</div><div class="line"></div><div class="line">(*r).do_something();</div><div class="line"></div><div class="line">consume(*r);</div></div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>a reference to the contained value </dd></dl>

</div>
</div>
<a id="a69f0b45ab457c1a90345cb908c5d6c56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69f0b45ab457c1a90345cb908c5d6c56">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RESULT_WARN_UNUSED RESULT_CPP14_CONSTEXPR auto <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;&amp; -&gt;  typename std::add_rvalue_reference&lt; T &gt;::type</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves a reference to the contained value. </p>
<p>This operator exists to give <code>result</code> an <code>optional</code>-like API for cases where it's known that the <code>result</code> already contains a value.</p>
<p>Care must be taken to ensure that this is only used in safe contexts where a <code>T</code> value is active.</p>
<dl class="section note"><dt>Note</dt><dd>The behaviour is undefined if <code>*this</code> does not contain a value</dd></dl>
<h3>Examples</h3>
<p>Basic Usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> r = cpp::result&lt;Widget,int&gt;{</div><div class="line">  make_widget()</div><div class="line">};</div><div class="line"></div><div class="line">(*r).do_something();</div><div class="line"></div><div class="line">consume(*r);</div></div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>a reference to the contained value </dd></dl>

</div>
</div>
<a id="a3d9c1a1a43982dfaae4abda97c7f53a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d9c1a1a43982dfaae4abda97c7f53a2">&#9670;&nbsp;</a></span>operator*() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RESULT_WARN_UNUSED constexpr auto <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp; -&gt;  typename std::add_lvalue_reference&lt; typename std::add_const&lt; T &gt;::type &gt;::type</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves a reference to the contained value. </p>
<p>This operator exists to give <code>result</code> an <code>optional</code>-like API for cases where it's known that the <code>result</code> already contains a value.</p>
<p>Care must be taken to ensure that this is only used in safe contexts where a <code>T</code> value is active.</p>
<dl class="section note"><dt>Note</dt><dd>The behaviour is undefined if <code>*this</code> does not contain a value</dd></dl>
<h3>Examples</h3>
<p>Basic Usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> r = cpp::result&lt;Widget,int&gt;{</div><div class="line">  make_widget()</div><div class="line">};</div><div class="line"></div><div class="line">(*r).do_something();</div><div class="line"></div><div class="line">consume(*r);</div></div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>a reference to the contained value </dd></dl>

</div>
</div>
<a id="ab4fb55a264f599d613776620cc2d793f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4fb55a264f599d613776620cc2d793f">&#9670;&nbsp;</a></span>operator*() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RESULT_WARN_UNUSED constexpr auto <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;&amp; -&gt;  typename std::add_rvalue_reference&lt; typename std::add_const&lt; T &gt;::type &gt;::type</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves a reference to the contained value. </p>
<p>This operator exists to give <code>result</code> an <code>optional</code>-like API for cases where it's known that the <code>result</code> already contains a value.</p>
<p>Care must be taken to ensure that this is only used in safe contexts where a <code>T</code> value is active.</p>
<dl class="section note"><dt>Note</dt><dd>The behaviour is undefined if <code>*this</code> does not contain a value</dd></dl>
<h3>Examples</h3>
<p>Basic Usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> r = cpp::result&lt;Widget,int&gt;{</div><div class="line">  make_widget()</div><div class="line">};</div><div class="line"></div><div class="line">(*r).do_something();</div><div class="line"></div><div class="line">consume(*r);</div></div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>a reference to the contained value </dd></dl>

</div>
</div>
<a id="a94ee155e428aae07e77869e5f8fe64fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94ee155e428aae07e77869e5f8fe64fd">&#9670;&nbsp;</a></span>operator->() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RESULT_WARN_UNUSED RESULT_CPP14_CONSTEXPR auto <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  typename std::remove_reference&lt; T &gt;::type *</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves a pointer to the contained value. </p>
<p>This operator exists to give <code>result</code> an <code>optional</code>-like API for cases where it's known that the <code>result</code> already contains a value.</p>
<p>Care must be taken to ensure that this is only used in safe contexts where a <code>T</code> value is active.</p>
<dl class="section note"><dt>Note</dt><dd>The behavior is undefined if <code>*this</code> does not contain a value.</dd></dl>
<h3>Examples</h3>
<p>Basic Usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> r = cpp::result&lt;Widget,int&gt;{</div><div class="line">  make_widget()</div><div class="line">};</div><div class="line"></div><div class="line">r-&gt;do_something();</div></div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>a pointer to the contained value </dd></dl>

</div>
</div>
<a id="aeff84a441f2b92f5f555421f56eec30c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeff84a441f2b92f5f555421f56eec30c">&#9670;&nbsp;</a></span>operator->() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RESULT_WARN_UNUSED constexpr auto <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt;  typename std::remove_reference&lt; typename std::add_const&lt; T &gt;::type &gt;::type *</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves a pointer to the contained value. </p>
<p>This operator exists to give <code>result</code> an <code>optional</code>-like API for cases where it's known that the <code>result</code> already contains a value.</p>
<p>Care must be taken to ensure that this is only used in safe contexts where a <code>T</code> value is active.</p>
<dl class="section note"><dt>Note</dt><dd>The behavior is undefined if <code>*this</code> does not contain a value.</dd></dl>
<h3>Examples</h3>
<p>Basic Usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> r = cpp::result&lt;Widget,int&gt;{</div><div class="line">  make_widget()</div><div class="line">};</div><div class="line"></div><div class="line">r-&gt;do_something();</div></div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>a pointer to the contained value </dd></dl>

</div>
</div>
<a id="a5307dea65a0fd87bdcd48c70a6827b10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5307dea65a0fd87bdcd48c70a6827b10">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a>&lt; T, E &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt;  <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a> &amp;=default</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assigns the result stored in <code>other</code>. </p>
<dl class="section note"><dt>Note</dt><dd>This assignment operator only participates in overload resolution if the following conditions are met:<ul>
<li><code>std::is_nothrow_copy_constructible_v&lt;T&gt;</code> is <code>true</code>, and</li>
<li><code>std::is_nothrow_copy_constructible_v&lt;E&gt;</code> is <code>true</code> this restriction guarantees that no '</li>
</ul>
</dd>
<dd>
This assignment operator is defined as trivial if the following conditions are all <code>true</code>:<ul>
<li><code>std::is_trivially_copy_constructible&lt;T&gt;::value</code></li>
<li><code>std::is_trivially_copy_constructible&lt;E&gt;::value</code></li>
<li><code>std::is_trivially_copy_assignable&lt;T&gt;::value</code></li>
<li><code>std::is_trivially_copy_assignable&lt;E&gt;::value</code></li>
<li><code>std::is_trivially_destructible&lt;T&gt;::value</code></li>
<li><code>std::is_trivially_destructible&lt;E&gt;::value</code></li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the other result to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7001dcd67ce0f053e77e70100fdc82e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7001dcd67ce0f053e77e70100fdc82e0">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a>&lt; T, E &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt;  <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a> &amp;=default</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assigns the result stored in <code>other</code>. </p>
<dl class="section note"><dt>Note</dt><dd>This assignment operator only participates in overload resolution if the following conditions are met:<ul>
<li><code>std::is_nothrow_copy_constructible_v&lt;T&gt;</code> is <code>true</code>, and</li>
<li><code>std::is_nothrow_copy_constructible_v&lt;E&gt;</code> is <code>true</code> this restriction guarantees that no 'valueless_by_exception` state may occur.</li>
</ul>
</dd>
<dd>
This assignment operator is defined as trivial if the following conditions are all <code>true</code>:<ul>
<li><code>std::is_trivially_move_constructible&lt;T&gt;::value</code></li>
<li><code>std::is_trivially_move_constructible&lt;E&gt;::value</code></li>
<li><code>std::is_trivially_move_assignable&lt;T&gt;::value</code></li>
<li><code>std::is_trivially_move_assignable&lt;E&gt;::value</code></li>
<li><code>std::is_trivially_destructible&lt;T&gt;::value</code></li>
<li><code>std::is_trivially_destructible&lt;E&gt;::value</code></li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the other result to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afa0909f15e9e8b97cfdf89bc4e880176"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa0909f15e9e8b97cfdf89bc4e880176">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<div class="memtemplate">
template&lt;typename T2 , typename E2 , typename  = typename std::enable_if&lt;detail::result_is_copy_convert_assignable&lt;T,E,T2,E2&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a>&lt; T2, E2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const &amp; -&gt;  <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy-converts the state of <code>other</code>. </p>
<p>If both <code>*this</code> and <code>other</code> contain either values or errors, the underlying value is constructed as if through assignment.</p>
<p>Otherwise if <code>*this</code> contains a value, but <code>other</code> contains an error, then the contained value is destroyed by calling its destructor. <code>*this</code> will no longer contain a value after the call, and will now contain <code>E</code> constructed as if direct-initializing (but not direct-list-initializing) an object with an argument of <code>const E2&amp;</code>.</p>
<p>If <code>other</code> contains a value and <code>*this</code> contains an error, then the contained error is destroyed by calling its destructor. <code>*this</code> now contains a value constructed as if direct-initializing (but not direct-list-initializing) an object with an argument of <code>const T2&amp;</code>.</p>
<dl class="section note"><dt>Note</dt><dd>The function does not participate in overload resolution unless<ul>
<li><code>std::is_nothrow_constructible_v&lt;T, const T2&amp;&gt;</code>, <code>std::is_assignable_v&lt;T&amp;, const T2&amp;&gt;</code>, <code>std::is_nothrow_constructible_v&lt;E, const E2&amp;&gt;</code>, <code>std::is_assignable_v&lt;E&amp;, const E2&amp;&gt;</code> are all true.</li>
<li>T is not constructible, convertible, or assignable from any expression of type (possibly const) <code>result&lt;T2,E2&gt;</code></li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the other result object to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to <code>(*this)</code> </dd></dl>

</div>
</div>
<a id="aa7964841611e21dcdaa0c6ad324b65be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7964841611e21dcdaa0c6ad324b65be">&#9670;&nbsp;</a></span>operator=() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<div class="memtemplate">
template&lt;typename T2 , typename E2 , typename  = typename std::enable_if&lt;detail::result_is_move_convert_assignable&lt;T,E,T2,E2&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a>&lt; T2, E2 &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> &amp;&amp; -&gt;  <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move-converts the state of <code>other</code>. </p>
<p>If both <code>*this</code> and <code>other</code> contain either values or errors, the underlying value is constructed as if through move-assignment.</p>
<p>Otherwise if <code>*this</code> contains a value, but <code>other</code> contains an error, then the contained value is destroyed by calling its destructor. <code>*this</code> will no longer contain a value after the call, and will now contain <code>E</code> constructed as if direct-initializing (but not direct-list-initializing) an object with an argument of <code>E2&amp;&amp;</code>.</p>
<p>If <code>other</code> contains a value and <code>*this</code> contains an error, then the contained error is destroyed by calling its destructor. <code>*this</code> now contains a value constructed as if direct-initializing (but not direct-list-initializing) an object with an argument of <code>T2&amp;&amp;</code>.</p>
<dl class="section note"><dt>Note</dt><dd>The function does not participate in overload resolution unless<ul>
<li><code>std::is_nothrow_constructible_v&lt;T, T2&amp;&amp;&gt;</code>, <code>std::is_assignable_v&lt;T&amp;, T2&amp;&amp;&gt;</code>, <code>std::is_nothrow_constructible_v&lt;E, E2&amp;&amp;&gt;</code>, <code>std::is_assignable_v&lt;E&amp;, E2&amp;&amp;&gt;</code> are all true.</li>
<li>T is not constructible, convertible, or assignable from any expression of type (possibly const) <code>result&lt;T2,E2&gt;</code></li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the other result object to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to <code>(*this)</code> </dd></dl>

</div>
</div>
<a id="aedce2ad25c705ae82c5bc1ebe1edc0d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedce2ad25c705ae82c5bc1ebe1edc0d9">&#9670;&nbsp;</a></span>operator=() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<div class="memtemplate">
template&lt;typename U , typename  = typename std::enable_if&lt;detail::result_is_value_assignable&lt;T,U&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">U &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt;  <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perfect-forwarded assignment. </p>
<p>Depending on whether <code>*this</code> contains a value before the call, the contained value is either direct-initialized from std::forward&lt;U&gt;(value) or assigned from std::forward&lt;U&gt;(value).</p>
<dl class="section note"><dt>Note</dt><dd>The function does not participate in overload resolution unless<ul>
<li><code>std::decay_t&lt;U&gt;</code> is not a result type,</li>
<li><code>std::decay_t&lt;U&gt;</code> is not a failure type</li>
<li><code>std::is_nothrow_constructible_v&lt;T, U&gt;</code> is <code>true</code></li>
<li><code>std::is_assignable_v&lt;T&amp;, U&gt;</code> is <code>true</code></li>
<li>and at least one of the following is <code>true</code>:<ul>
<li><code>T</code> is not a scalar type;</li>
<li><code>std::decay_t&lt;U&gt;</code> is not <code>T</code>.</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>to assign to the contained value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to <code>(*this)</code> </dd></dl>

</div>
</div>
<a id="aae159b2584abc4f61f055c60888dbee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae159b2584abc4f61f055c60888dbee0">&#9670;&nbsp;</a></span>operator=() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<div class="memtemplate">
template&lt;typename E2 , typename  = typename std::enable_if&lt;detail::result_is_failure_assignable&lt;E,const E2&amp;&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/dd0/classcpp_1_1bitwizeshift_1_1failure.html">failure</a>&lt; E2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const &amp; -&gt;  <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perfect-forwarded assignment. </p>
<p>Depending on whether <code>*this</code> contains a value before the call, the contained value is either direct-initialized from <code>std::forward&lt;U&gt;(value)</code> or assigned from <code>std::forward&lt;U&gt;(value)</code>.</p>
<dl class="section note"><dt>Note</dt><dd>The function does not participate in overload resolution unless<ul>
<li><code>std::is_nothrow_constructible_v&lt;E, E2&gt;</code> is <code>true</code></li>
<li><code>std::is_assignable_v&lt;T&amp;, U&gt;</code> is <code>true</code></li>
<li>and at least one of the following is true:<ul>
<li><code>T</code> is not a scalar type;</li>
<li><code>decay_t&lt;U&gt;</code> is not <code>T</code>.</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>to assign to the contained value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to <code>(*this)</code> </dd></dl>

</div>
</div>
<a id="ae3b72a65bedcf9ddabfab257d4873764"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3b72a65bedcf9ddabfab257d4873764">&#9670;&nbsp;</a></span>operator=() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<div class="memtemplate">
template&lt;typename E2 , typename  = typename std::enable_if&lt;detail::result_is_failure_assignable&lt;E,E2&amp;&amp;&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dd0/classcpp_1_1bitwizeshift_1_1failure.html">failure</a>&lt; E2 &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> &amp;&amp; -&gt;  <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">result</a> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perfect-forwarded assignment. </p>
<p>Depending on whether <code>*this</code> contains a value before the call, the contained value is either direct-initialized from <code>std::forward&lt;U&gt;(value)</code> or assigned from <code>std::forward&lt;U&gt;(value)</code>.</p>
<dl class="section note"><dt>Note</dt><dd>The function does not participate in overload resolution unless<ul>
<li><code>std::is_nothrow_constructible_v&lt;E, E2&gt;</code> is <code>true</code></li>
<li><code>std::is_assignable_v&lt;T&amp;, U&gt;</code> is <code>true</code></li>
<li>and at least one of the following is true:<ul>
<li><code>T</code> is not a scalar type;</li>
<li><code>decay_t&lt;U&gt;</code> is not <code>T</code>.</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>to assign to the contained value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to <code>(*this)</code> </dd></dl>

</div>
</div>
<a id="ab3ba0d040afc7020329fcc840dcb855e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3ba0d040afc7020329fcc840dcb855e">&#9670;&nbsp;</a></span>value() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RESULT_WARN_UNUSED RESULT_CPP14_CONSTEXPR auto <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp; -&gt;  typename std::add_lvalue_reference&lt; T &gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference to the contained value. </p>
<p>This function provides checked (throwing) access to the underlying value. The constness and refness of this result is propagated to the underlying reference.</p>
<p>If this contains an error, an exception is thrown containing the underlying error. The error is consumed propagating the same constness and refness of this result.</p>
<h3>Examples</h3>
<p>Basic Usage:</p>
<div class="fragment"><div class="line">assert(cpp::result&lt;int,int&gt;{42}.value() == 42);</div><div class="line"></div><div class="line"><span class="keyword">auto</span> r = cpp::result&lt;std::unique_ptr&lt;int&gt;,<span class="keywordtype">int</span>&gt;{</div><div class="line">  std::make_unique&lt;int&gt;(42)</div><div class="line">};</div><div class="line"><span class="keyword">auto</span> s = std::move(r).value();</div><div class="line"></div><div class="line"><span class="keywordflow">try</span> {</div><div class="line">  <span class="keyword">auto</span> r = cpp::result&lt;int,int&gt;{ cpp::fail(42) };</div><div class="line">  <span class="keyword">auto</span> v = r.value();</div><div class="line">} <span class="keywordflow">catch</span> (<span class="keyword">const</span> cpp::bad_result_access&lt;int&gt;&amp; e) {</div><div class="line">  assert(e.error() == 42);</div><div class="line">}</div></div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">bad_result_access&lt;E&gt;</td><td>if <code>*this</code> does not contain a value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of <code>*this</code> </dd></dl>

</div>
</div>
<a id="ab18037be1f183edc5fda0a819f2a1ecd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab18037be1f183edc5fda0a819f2a1ecd">&#9670;&nbsp;</a></span>value() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RESULT_WARN_UNUSED RESULT_CPP14_CONSTEXPR auto <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;&amp; -&gt;  typename std::add_rvalue_reference&lt; T &gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference to the contained value. </p>
<p>This function provides checked (throwing) access to the underlying value. The constness and refness of this result is propagated to the underlying reference.</p>
<p>If this contains an error, an exception is thrown containing the underlying error. The error is consumed propagating the same constness and refness of this result.</p>
<h3>Examples</h3>
<p>Basic Usage:</p>
<div class="fragment"><div class="line">assert(cpp::result&lt;int,int&gt;{42}.value() == 42);</div><div class="line"></div><div class="line"><span class="keyword">auto</span> r = cpp::result&lt;std::unique_ptr&lt;int&gt;,<span class="keywordtype">int</span>&gt;{</div><div class="line">  std::make_unique&lt;int&gt;(42)</div><div class="line">};</div><div class="line"><span class="keyword">auto</span> s = std::move(r).value();</div><div class="line"></div><div class="line"><span class="keywordflow">try</span> {</div><div class="line">  <span class="keyword">auto</span> r = cpp::result&lt;int,int&gt;{ cpp::fail(42) };</div><div class="line">  <span class="keyword">auto</span> v = r.value();</div><div class="line">} <span class="keywordflow">catch</span> (<span class="keyword">const</span> cpp::bad_result_access&lt;int&gt;&amp; e) {</div><div class="line">  assert(e.error() == 42);</div><div class="line">}</div></div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">bad_result_access&lt;E&gt;</td><td>if <code>*this</code> does not contain a value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of <code>*this</code> </dd></dl>

</div>
</div>
<a id="a4c301c005ed696c904f017e6c69fbae2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c301c005ed696c904f017e6c69fbae2">&#9670;&nbsp;</a></span>value() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RESULT_WARN_UNUSED constexpr auto <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp; -&gt;  typename std::add_lvalue_reference&lt; typename std::add_const&lt; T &gt;::type &gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference to the contained value. </p>
<p>This function provides checked (throwing) access to the underlying value. The constness and refness of this result is propagated to the underlying reference.</p>
<p>If this contains an error, an exception is thrown containing the underlying error. The error is consumed propagating the same constness and refness of this result.</p>
<h3>Examples</h3>
<p>Basic Usage:</p>
<div class="fragment"><div class="line">assert(cpp::result&lt;int,int&gt;{42}.value() == 42);</div><div class="line"></div><div class="line"><span class="keyword">auto</span> r = cpp::result&lt;std::unique_ptr&lt;int&gt;,<span class="keywordtype">int</span>&gt;{</div><div class="line">  std::make_unique&lt;int&gt;(42)</div><div class="line">};</div><div class="line"><span class="keyword">auto</span> s = std::move(r).value();</div><div class="line"></div><div class="line"><span class="keywordflow">try</span> {</div><div class="line">  <span class="keyword">auto</span> r = cpp::result&lt;int,int&gt;{ cpp::fail(42) };</div><div class="line">  <span class="keyword">auto</span> v = r.value();</div><div class="line">} <span class="keywordflow">catch</span> (<span class="keyword">const</span> cpp::bad_result_access&lt;int&gt;&amp; e) {</div><div class="line">  assert(e.error() == 42);</div><div class="line">}</div></div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">bad_result_access&lt;E&gt;</td><td>if <code>*this</code> does not contain a value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of <code>*this</code> </dd></dl>

</div>
</div>
<a id="a96ce9e22e0ff3041a45c1ad213d27e7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96ce9e22e0ff3041a45c1ad213d27e7b">&#9670;&nbsp;</a></span>value() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RESULT_WARN_UNUSED constexpr auto <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;&amp; -&gt;  typename std::add_rvalue_reference&lt; typename std::add_const&lt; T &gt;::type &gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference to the contained value. </p>
<p>This function provides checked (throwing) access to the underlying value. The constness and refness of this result is propagated to the underlying reference.</p>
<p>If this contains an error, an exception is thrown containing the underlying error. The error is consumed propagating the same constness and refness of this result.</p>
<h3>Examples</h3>
<p>Basic Usage:</p>
<div class="fragment"><div class="line">assert(cpp::result&lt;int,int&gt;{42}.value() == 42);</div><div class="line"></div><div class="line"><span class="keyword">auto</span> r = cpp::result&lt;std::unique_ptr&lt;int&gt;,<span class="keywordtype">int</span>&gt;{</div><div class="line">  std::make_unique&lt;int&gt;(42)</div><div class="line">};</div><div class="line"><span class="keyword">auto</span> s = std::move(r).value();</div><div class="line"></div><div class="line"><span class="keywordflow">try</span> {</div><div class="line">  <span class="keyword">auto</span> r = cpp::result&lt;int,int&gt;{ cpp::fail(42) };</div><div class="line">  <span class="keyword">auto</span> v = r.value();</div><div class="line">} <span class="keywordflow">catch</span> (<span class="keyword">const</span> cpp::bad_result_access&lt;int&gt;&amp; e) {</div><div class="line">  assert(e.error() == 42);</div><div class="line">}</div></div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">bad_result_access&lt;E&gt;</td><td>if <code>*this</code> does not contain a value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of <code>*this</code> </dd></dl>

</div>
</div>
<a id="a940d1ef3f46c158696db5f4f0c47440d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a940d1ef3f46c158696db5f4f0c47440d">&#9670;&nbsp;</a></span>value_or() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RESULT_WARN_UNUSED constexpr auto <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::value_or </td>
          <td>(</td>
          <td class="paramtype">U &amp;&amp;&#160;</td>
          <td class="paramname"><em>default_value</em></td><td>)</td>
          <td> const &amp; -&gt;  typename std::remove_reference&lt; T &gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the contained value if <code>*this</code> has a value, otherwise returns <code>default_value</code>. </p>
<h3>Examples</h3>
<p>Basic Usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> r = cpp::result&lt;int,int&gt;{42};</div><div class="line">assert(r.value_or(0) == 42);</div><div class="line"></div><div class="line"><span class="keyword">auto</span> r = cpp::result&lt;int,int&gt;{cpp::fail(42)};</div><div class="line">assert(r.value_or(0) == 0);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">default_value</td><td>the value to use in case <code>*this</code> contains an error </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the contained value or <code>default_value</code> </dd></dl>

</div>
</div>
<a id="a86ecfa9df078e95b21e7ceed021e12db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86ecfa9df078e95b21e7ceed021e12db">&#9670;&nbsp;</a></span>value_or() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RESULT_WARN_UNUSED RESULT_CPP14_CONSTEXPR auto <a class="el" href="../../db/d9a/classcpp_1_1bitwizeshift_1_1result.html">cpp::bitwizeshift::result</a>&lt; T, E &gt;::value_or </td>
          <td>(</td>
          <td class="paramtype">U &amp;&amp;&#160;</td>
          <td class="paramname"><em>default_value</em></td><td>)</td>
          <td> &amp;&amp; -&gt;  typename std::remove_reference&lt; T &gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the contained value if <code>*this</code> has a value, otherwise returns <code>default_value</code>. </p>
<h3>Examples</h3>
<p>Basic Usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> r = cpp::result&lt;int,int&gt;{42};</div><div class="line">assert(r.value_or(0) == 42);</div><div class="line"></div><div class="line"><span class="keyword">auto</span> r = cpp::result&lt;int,int&gt;{cpp::fail(42)};</div><div class="line">assert(r.value_or(0) == 0);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">default_value</td><td>the value to use in case <code>*this</code> contains an error </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the contained value or <code>default_value</code> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/<a class="el" href="../../de/d80/result_8hpp_source.html">result.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
 <!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
      <a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.png" alt="doxygen"></a>
    </li>
  </ul>
</div>
</body>
</html>